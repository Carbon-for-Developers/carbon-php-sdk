<?php
/**
 * UtilitiesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Carbon
 * @author   Konfig
 * @link     https://konfigthis.com
 */

/**
 * Carbon
 *
 * Connect external data to LLMs, no matter the source.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://konfigthis.com
 */


namespace Carbon\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\BodySummarizer;
use GuzzleHttp\Middleware;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Utils;
use Carbon\ApiException;
use Carbon\Configuration;
use Carbon\HeaderSelector;
use Carbon\ObjectSerializer;

class UtilitiesApi extends \Carbon\CustomApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'fetchUrls' => [
            'application/json',
        ],
        'fetchWebpage' => [
            'application/json',
        ],
        'fetchYoutubeTranscripts' => [
            'application/json',
        ],
        'processSitemap' => [
            'application/json',
        ],
        'scrapeSitemap' => [
            'application/json',
        ],
        'scrapeWeb' => [
            'application/json',
        ],
        'searchUrls' => [
            'application/json',
        ],
        'userWebpages' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $clientOptions = [];
        if (!$config->getVerifySsl()) $clientOptions["verify"] = false;

        // Do not truncate error messages
        // https://github.com/guzzle/guzzle/issues/2185#issuecomment-800293420
        $stack = new HandlerStack(Utils::chooseHandler());
        $stack->push(Middleware::httpErrors(new BodySummarizer(10000)), 'http_errors');
        $stack->push(Middleware::redirect(), 'allow_redirects');
        $stack->push(Middleware::cookies(), 'cookies');
        $stack->push(Middleware::prepareBody(), 'prepare_body');
        $clientOptions["handler"] = $stack;

        $this->client = $client ?: new Client($clientOptions);
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * For initializing request body parameter
     */
    private function setRequestBodyProperty(&$body, $property, $value) {
        if ($body === null) $body = [];
        // user did not pass in a value for this parameter
        if ($value === SENTINEL_VALUE) return;
        $body[$property] = $value;
    }

    /**
     * Operation fetchUrls
     *
     * Fetch Urls
     *
     * Extracts all URLs from a webpage.   Args:     url (str): URL of the webpage  Returns:     FetchURLsResponse: A response object with a list of URLs extracted from the webpage and the webpage content.
     *
     * @param  string $url url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchUrls'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\FetchURLsResponse|\Carbon\Model\HTTPValidationError
     * @deprecated
     */
    public function fetchUrls(
        $url,

        string $contentType = self::contentTypes['fetchUrls'][0]
    )
    {

        list($response) = $this->fetchUrlsWithHttpInfo($url, $contentType);
        return $response;
    }

    /**
     * Operation fetchUrlsWithHttpInfo
     *
     * Fetch Urls
     *
     * Extracts all URLs from a webpage.   Args:     url (str): URL of the webpage  Returns:     FetchURLsResponse: A response object with a list of URLs extracted from the webpage and the webpage content.
     *
     * @param  string $url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchUrls'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\FetchURLsResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function fetchUrlsWithHttpInfo($url, string $contentType = self::contentTypes['fetchUrls'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fetchUrlsRequest($url, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fetchUrlsWithHttpInfo(
                        $url,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\FetchURLsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\FetchURLsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\FetchURLsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\FetchURLsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\FetchURLsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fetchUrlsAsync
     *
     * Fetch Urls
     *
     * Extracts all URLs from a webpage.   Args:     url (str): URL of the webpage  Returns:     FetchURLsResponse: A response object with a list of URLs extracted from the webpage and the webpage content.
     *
     * @param  string $url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function fetchUrlsAsync(
        $url,

        string $contentType = self::contentTypes['fetchUrls'][0]
    )
    {

        return $this->fetchUrlsAsyncWithHttpInfo($url, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchUrlsAsyncWithHttpInfo
     *
     * Fetch Urls
     *
     * Extracts all URLs from a webpage.   Args:     url (str): URL of the webpage  Returns:     FetchURLsResponse: A response object with a list of URLs extracted from the webpage and the webpage content.
     *
     * @param  string $url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function fetchUrlsAsyncWithHttpInfo($url, string $contentType = self::contentTypes['fetchUrls'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\FetchURLsResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fetchUrlsRequest($url, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchUrls'
     *
     * @param  string $url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function fetchUrlsRequest($url, string $contentType = self::contentTypes['fetchUrls'][0])
    {

        // Check if $url is a string
        if ($url !== SENTINEL_VALUE && !is_string($url)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($url, true), gettype($url)));
        }
        // verify the required parameter 'url' is set
        if ($url === SENTINEL_VALUE || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter url when calling fetchUrls'
            );
        }


        $resourcePath = '/fetch_urls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($url !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $url,
                'url', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fetchWebpage
     *
     * Fetch Urls V2
     *
     * @param  \Carbon\Model\FetchURLsRequest $fetch_urls_request fetch_urls_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchWebpage'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\Carbon\Model\HTTPValidationError
     */
    public function fetchWebpage(

        $url,
        string $contentType = self::contentTypes['fetchWebpage'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "url", $url);
        $fetch_urls_request = $_body;

        list($response) = $this->fetchWebpageWithHttpInfo($fetch_urls_request, $contentType);
        return $response;
    }

    /**
     * Operation fetchWebpageWithHttpInfo
     *
     * Fetch Urls V2
     *
     * @param  \Carbon\Model\FetchURLsRequest $fetch_urls_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchWebpage'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function fetchWebpageWithHttpInfo($fetch_urls_request, string $contentType = self::contentTypes['fetchWebpage'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fetchWebpageRequest($fetch_urls_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fetchWebpageWithHttpInfo(
                        $fetch_urls_request,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fetchWebpageAsync
     *
     * Fetch Urls V2
     *
     * @param  \Carbon\Model\FetchURLsRequest $fetch_urls_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchWebpage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchWebpageAsync(

        $url,
        string $contentType = self::contentTypes['fetchWebpage'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "url", $url);
        $fetch_urls_request = $_body;

        return $this->fetchWebpageAsyncWithHttpInfo($fetch_urls_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchWebpageAsyncWithHttpInfo
     *
     * Fetch Urls V2
     *
     * @param  \Carbon\Model\FetchURLsRequest $fetch_urls_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchWebpage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchWebpageAsyncWithHttpInfo($fetch_urls_request, string $contentType = self::contentTypes['fetchWebpage'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fetchWebpageRequest($fetch_urls_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchWebpage'
     *
     * @param  \Carbon\Model\FetchURLsRequest $fetch_urls_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchWebpage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fetchWebpageRequest($fetch_urls_request, string $contentType = self::contentTypes['fetchWebpage'][0])
    {

        if ($fetch_urls_request !== SENTINEL_VALUE) {
            if (!($fetch_urls_request instanceof \Carbon\Model\FetchURLsRequest)) {
                if (!is_array($fetch_urls_request))
                    throw new \InvalidArgumentException('"fetch_urls_request" must be associative array or an instance of \Carbon\Model\FetchURLsRequest UtilitiesApi.fetchWebpage.');
                else
                    $fetch_urls_request = new \Carbon\Model\FetchURLsRequest($fetch_urls_request);
            }
        }
        // verify the required parameter 'fetch_urls_request' is set
        if ($fetch_urls_request === SENTINEL_VALUE || (is_array($fetch_urls_request) && count($fetch_urls_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter fetch_urls_request when calling fetchWebpage'
            );
        }


        $resourcePath = '/fetch_webpage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($fetch_urls_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($fetch_urls_request));
            } else {
                $httpBody = $fetch_urls_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation fetchYoutubeTranscripts
     *
     * Fetch Youtube Transcripts
     *
     * Fetches english transcripts from YouTube videos.  Args:     id (str): The ID of the YouTube video.      raw (bool): Whether to return the raw transcript or not. Defaults to False.  Returns:     dict: A dictionary with the transcript of the YouTube video.
     *
     * @param  string $id id (required)
     * @param  bool $raw raw (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchYoutubeTranscripts'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\YoutubeTranscriptResponse|\Carbon\Model\HTTPValidationError
     */
    public function fetchYoutubeTranscripts(
        $id,
        $raw = false,

        string $contentType = self::contentTypes['fetchYoutubeTranscripts'][0]
    )
    {

        list($response) = $this->fetchYoutubeTranscriptsWithHttpInfo($id, $raw, $contentType);
        return $response;
    }

    /**
     * Operation fetchYoutubeTranscriptsWithHttpInfo
     *
     * Fetch Youtube Transcripts
     *
     * Fetches english transcripts from YouTube videos.  Args:     id (str): The ID of the YouTube video.      raw (bool): Whether to return the raw transcript or not. Defaults to False.  Returns:     dict: A dictionary with the transcript of the YouTube video.
     *
     * @param  string $id (required)
     * @param  bool $raw (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchYoutubeTranscripts'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\YoutubeTranscriptResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function fetchYoutubeTranscriptsWithHttpInfo($id, $raw = false, string $contentType = self::contentTypes['fetchYoutubeTranscripts'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fetchYoutubeTranscriptsRequest($id, $raw, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->fetchYoutubeTranscriptsWithHttpInfo(
                        $id,
                        $raw,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\YoutubeTranscriptResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\YoutubeTranscriptResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\YoutubeTranscriptResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\YoutubeTranscriptResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\YoutubeTranscriptResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation fetchYoutubeTranscriptsAsync
     *
     * Fetch Youtube Transcripts
     *
     * Fetches english transcripts from YouTube videos.  Args:     id (str): The ID of the YouTube video.      raw (bool): Whether to return the raw transcript or not. Defaults to False.  Returns:     dict: A dictionary with the transcript of the YouTube video.
     *
     * @param  string $id (required)
     * @param  bool $raw (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchYoutubeTranscripts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchYoutubeTranscriptsAsync(
        $id,
        $raw = false,

        string $contentType = self::contentTypes['fetchYoutubeTranscripts'][0]
    )
    {

        return $this->fetchYoutubeTranscriptsAsyncWithHttpInfo($id, $raw, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation fetchYoutubeTranscriptsAsyncWithHttpInfo
     *
     * Fetch Youtube Transcripts
     *
     * Fetches english transcripts from YouTube videos.  Args:     id (str): The ID of the YouTube video.      raw (bool): Whether to return the raw transcript or not. Defaults to False.  Returns:     dict: A dictionary with the transcript of the YouTube video.
     *
     * @param  string $id (required)
     * @param  bool $raw (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchYoutubeTranscripts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function fetchYoutubeTranscriptsAsyncWithHttpInfo($id, $raw = false, string $contentType = self::contentTypes['fetchYoutubeTranscripts'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\YoutubeTranscriptResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->fetchYoutubeTranscriptsRequest($id, $raw, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'fetchYoutubeTranscripts'
     *
     * @param  string $id (required)
     * @param  bool $raw (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['fetchYoutubeTranscripts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function fetchYoutubeTranscriptsRequest($id, $raw = false, string $contentType = self::contentTypes['fetchYoutubeTranscripts'][0])
    {

        // Check if $id is a string
        if ($id !== SENTINEL_VALUE && !is_string($id)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($id, true), gettype($id)));
        }
        // verify the required parameter 'id' is set
        if ($id === SENTINEL_VALUE || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter id when calling fetchYoutubeTranscripts'
            );
        }


        $resourcePath = '/fetch_youtube_transcript';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $id,
                'id', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }
        if ($raw !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $raw,
                'raw', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation processSitemap
     *
     * Sitemap
     *
     * Retrieves all URLs from a sitemap, which can subsequently be utilized with our &#x60;web_scrape&#x60; endpoint.  &lt;!--Args:     url (str): URL of the sitemap  Returns:     dict: A dictionary with a list of URLs extracted from the sitemap.--&gt;
     *
     * @param  string $url url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processSitemap'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\Carbon\Model\HTTPValidationError
     */
    public function processSitemap(
        $url,

        string $contentType = self::contentTypes['processSitemap'][0]
    )
    {

        list($response) = $this->processSitemapWithHttpInfo($url, $contentType);
        return $response;
    }

    /**
     * Operation processSitemapWithHttpInfo
     *
     * Sitemap
     *
     * Retrieves all URLs from a sitemap, which can subsequently be utilized with our &#x60;web_scrape&#x60; endpoint.  &lt;!--Args:     url (str): URL of the sitemap  Returns:     dict: A dictionary with a list of URLs extracted from the sitemap.--&gt;
     *
     * @param  string $url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processSitemap'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function processSitemapWithHttpInfo($url, string $contentType = self::contentTypes['processSitemap'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->processSitemapRequest($url, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->processSitemapWithHttpInfo(
                        $url,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation processSitemapAsync
     *
     * Sitemap
     *
     * Retrieves all URLs from a sitemap, which can subsequently be utilized with our &#x60;web_scrape&#x60; endpoint.  &lt;!--Args:     url (str): URL of the sitemap  Returns:     dict: A dictionary with a list of URLs extracted from the sitemap.--&gt;
     *
     * @param  string $url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processSitemap'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processSitemapAsync(
        $url,

        string $contentType = self::contentTypes['processSitemap'][0]
    )
    {

        return $this->processSitemapAsyncWithHttpInfo($url, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation processSitemapAsyncWithHttpInfo
     *
     * Sitemap
     *
     * Retrieves all URLs from a sitemap, which can subsequently be utilized with our &#x60;web_scrape&#x60; endpoint.  &lt;!--Args:     url (str): URL of the sitemap  Returns:     dict: A dictionary with a list of URLs extracted from the sitemap.--&gt;
     *
     * @param  string $url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processSitemap'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function processSitemapAsyncWithHttpInfo($url, string $contentType = self::contentTypes['processSitemap'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->processSitemapRequest($url, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'processSitemap'
     *
     * @param  string $url (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processSitemap'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function processSitemapRequest($url, string $contentType = self::contentTypes['processSitemap'][0])
    {

        // Check if $url is a string
        if ($url !== SENTINEL_VALUE && !is_string($url)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($url, true), gettype($url)));
        }
        // verify the required parameter 'url' is set
        if ($url === SENTINEL_VALUE || (is_array($url) && count($url) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter url when calling processSitemap'
            );
        }


        $resourcePath = '/process_sitemap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($url !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $url,
                'url', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation scrapeSitemap
     *
     * Scrape Sitemap
     *
     * Extracts all URLs from a sitemap and performs a web scrape on each of them.  Args:     sitemap_url (str): URL of the sitemap  Returns:     dict: A response object with the status of the scraping job message.--&gt;
     *
     * @param  \Carbon\Model\SitemapScrapeRequest $sitemap_scrape_request sitemap_scrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeSitemap'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\Carbon\Model\HTTPValidationError
     */
    public function scrapeSitemap(

        $url,
        $tags = SENTINEL_VALUE,
        $max_pages_to_scrape = SENTINEL_VALUE,
        $chunk_size = 1500,
        $chunk_overlap = 20,
        $skip_embedding_generation = false,
        $enable_auto_sync = false,
        $generate_sparse_vectors = false,
        $prepend_filename_to_chunks = false,
        $html_tags_to_skip = SENTINEL_VALUE,
        $css_classes_to_skip = SENTINEL_VALUE,
        $css_selectors_to_skip = SENTINEL_VALUE,
        $embedding_model = SENTINEL_VALUE,
        $url_paths_to_include = SENTINEL_VALUE,
        $url_paths_to_exclude = SENTINEL_VALUE,
        $urls_to_scrape = SENTINEL_VALUE,
        $download_css_and_media = false,
        $generate_chunks_only = false,
        $store_file_only = false,
        $use_premium_proxies = false,
        string $contentType = self::contentTypes['scrapeSitemap'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "tags", $tags);
        $this->setRequestBodyProperty($_body, "url", $url);
        $this->setRequestBodyProperty($_body, "max_pages_to_scrape", $max_pages_to_scrape);
        $this->setRequestBodyProperty($_body, "chunk_size", $chunk_size);
        $this->setRequestBodyProperty($_body, "chunk_overlap", $chunk_overlap);
        $this->setRequestBodyProperty($_body, "skip_embedding_generation", $skip_embedding_generation);
        $this->setRequestBodyProperty($_body, "enable_auto_sync", $enable_auto_sync);
        $this->setRequestBodyProperty($_body, "generate_sparse_vectors", $generate_sparse_vectors);
        $this->setRequestBodyProperty($_body, "prepend_filename_to_chunks", $prepend_filename_to_chunks);
        $this->setRequestBodyProperty($_body, "html_tags_to_skip", $html_tags_to_skip);
        $this->setRequestBodyProperty($_body, "css_classes_to_skip", $css_classes_to_skip);
        $this->setRequestBodyProperty($_body, "css_selectors_to_skip", $css_selectors_to_skip);
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "url_paths_to_include", $url_paths_to_include);
        $this->setRequestBodyProperty($_body, "url_paths_to_exclude", $url_paths_to_exclude);
        $this->setRequestBodyProperty($_body, "urls_to_scrape", $urls_to_scrape);
        $this->setRequestBodyProperty($_body, "download_css_and_media", $download_css_and_media);
        $this->setRequestBodyProperty($_body, "generate_chunks_only", $generate_chunks_only);
        $this->setRequestBodyProperty($_body, "store_file_only", $store_file_only);
        $this->setRequestBodyProperty($_body, "use_premium_proxies", $use_premium_proxies);
        $sitemap_scrape_request = $_body;

        list($response) = $this->scrapeSitemapWithHttpInfo($sitemap_scrape_request, $contentType);
        return $response;
    }

    /**
     * Operation scrapeSitemapWithHttpInfo
     *
     * Scrape Sitemap
     *
     * Extracts all URLs from a sitemap and performs a web scrape on each of them.  Args:     sitemap_url (str): URL of the sitemap  Returns:     dict: A response object with the status of the scraping job message.--&gt;
     *
     * @param  \Carbon\Model\SitemapScrapeRequest $sitemap_scrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeSitemap'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function scrapeSitemapWithHttpInfo($sitemap_scrape_request, string $contentType = self::contentTypes['scrapeSitemap'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->scrapeSitemapRequest($sitemap_scrape_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->scrapeSitemapWithHttpInfo(
                        $sitemap_scrape_request,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scrapeSitemapAsync
     *
     * Scrape Sitemap
     *
     * Extracts all URLs from a sitemap and performs a web scrape on each of them.  Args:     sitemap_url (str): URL of the sitemap  Returns:     dict: A response object with the status of the scraping job message.--&gt;
     *
     * @param  \Carbon\Model\SitemapScrapeRequest $sitemap_scrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeSitemap'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scrapeSitemapAsync(

        $url,
        $tags = SENTINEL_VALUE,
        $max_pages_to_scrape = SENTINEL_VALUE,
        $chunk_size = 1500,
        $chunk_overlap = 20,
        $skip_embedding_generation = false,
        $enable_auto_sync = false,
        $generate_sparse_vectors = false,
        $prepend_filename_to_chunks = false,
        $html_tags_to_skip = SENTINEL_VALUE,
        $css_classes_to_skip = SENTINEL_VALUE,
        $css_selectors_to_skip = SENTINEL_VALUE,
        $embedding_model = SENTINEL_VALUE,
        $url_paths_to_include = SENTINEL_VALUE,
        $url_paths_to_exclude = SENTINEL_VALUE,
        $urls_to_scrape = SENTINEL_VALUE,
        $download_css_and_media = false,
        $generate_chunks_only = false,
        $store_file_only = false,
        $use_premium_proxies = false,
        string $contentType = self::contentTypes['scrapeSitemap'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "tags", $tags);
        $this->setRequestBodyProperty($_body, "url", $url);
        $this->setRequestBodyProperty($_body, "max_pages_to_scrape", $max_pages_to_scrape);
        $this->setRequestBodyProperty($_body, "chunk_size", $chunk_size);
        $this->setRequestBodyProperty($_body, "chunk_overlap", $chunk_overlap);
        $this->setRequestBodyProperty($_body, "skip_embedding_generation", $skip_embedding_generation);
        $this->setRequestBodyProperty($_body, "enable_auto_sync", $enable_auto_sync);
        $this->setRequestBodyProperty($_body, "generate_sparse_vectors", $generate_sparse_vectors);
        $this->setRequestBodyProperty($_body, "prepend_filename_to_chunks", $prepend_filename_to_chunks);
        $this->setRequestBodyProperty($_body, "html_tags_to_skip", $html_tags_to_skip);
        $this->setRequestBodyProperty($_body, "css_classes_to_skip", $css_classes_to_skip);
        $this->setRequestBodyProperty($_body, "css_selectors_to_skip", $css_selectors_to_skip);
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "url_paths_to_include", $url_paths_to_include);
        $this->setRequestBodyProperty($_body, "url_paths_to_exclude", $url_paths_to_exclude);
        $this->setRequestBodyProperty($_body, "urls_to_scrape", $urls_to_scrape);
        $this->setRequestBodyProperty($_body, "download_css_and_media", $download_css_and_media);
        $this->setRequestBodyProperty($_body, "generate_chunks_only", $generate_chunks_only);
        $this->setRequestBodyProperty($_body, "store_file_only", $store_file_only);
        $this->setRequestBodyProperty($_body, "use_premium_proxies", $use_premium_proxies);
        $sitemap_scrape_request = $_body;

        return $this->scrapeSitemapAsyncWithHttpInfo($sitemap_scrape_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scrapeSitemapAsyncWithHttpInfo
     *
     * Scrape Sitemap
     *
     * Extracts all URLs from a sitemap and performs a web scrape on each of them.  Args:     sitemap_url (str): URL of the sitemap  Returns:     dict: A response object with the status of the scraping job message.--&gt;
     *
     * @param  \Carbon\Model\SitemapScrapeRequest $sitemap_scrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeSitemap'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scrapeSitemapAsyncWithHttpInfo($sitemap_scrape_request, string $contentType = self::contentTypes['scrapeSitemap'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->scrapeSitemapRequest($sitemap_scrape_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scrapeSitemap'
     *
     * @param  \Carbon\Model\SitemapScrapeRequest $sitemap_scrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeSitemap'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function scrapeSitemapRequest($sitemap_scrape_request, string $contentType = self::contentTypes['scrapeSitemap'][0])
    {

        if ($sitemap_scrape_request !== SENTINEL_VALUE) {
            if (!($sitemap_scrape_request instanceof \Carbon\Model\SitemapScrapeRequest)) {
                if (!is_array($sitemap_scrape_request))
                    throw new \InvalidArgumentException('"sitemap_scrape_request" must be associative array or an instance of \Carbon\Model\SitemapScrapeRequest UtilitiesApi.scrapeSitemap.');
                else
                    $sitemap_scrape_request = new \Carbon\Model\SitemapScrapeRequest($sitemap_scrape_request);
            }
        }
        // verify the required parameter 'sitemap_scrape_request' is set
        if ($sitemap_scrape_request === SENTINEL_VALUE || (is_array($sitemap_scrape_request) && count($sitemap_scrape_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter sitemap_scrape_request when calling scrapeSitemap'
            );
        }


        $resourcePath = '/scrape_sitemap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($sitemap_scrape_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($sitemap_scrape_request));
            } else {
                $httpBody = $sitemap_scrape_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation scrapeWeb
     *
     * Web Scrape
     *
     * Conduct a web scrape on a given webpage URL. Our web scraper is fully compatible with JavaScript and supports recursion depth, enabling you to efficiently extract all content from the target website.  &lt;!--Args:     scraping_requests (List[WebscrapeRequest]): A list of WebscrapeRequest objects.       Returns:     dict: A response object with the status of the scraping job message.--&gt;
     *
     * @param  \Carbon\Model\WebscrapeRequest[] $webscrape_request webscrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeWeb'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\Carbon\Model\HTTPValidationError
     */
    public function scrapeWeb(
        $body,

        string $contentType = self::contentTypes['scrapeWeb'][0]
    )
    {
        $_body = [];
        $webscrape_request = $body === SENTINEL_VALUE ? null : (empty($_body) ? $body : $_body);

        list($response) = $this->scrapeWebWithHttpInfo($webscrape_request, $contentType);
        return $response;
    }

    /**
     * Operation scrapeWebWithHttpInfo
     *
     * Web Scrape
     *
     * Conduct a web scrape on a given webpage URL. Our web scraper is fully compatible with JavaScript and supports recursion depth, enabling you to efficiently extract all content from the target website.  &lt;!--Args:     scraping_requests (List[WebscrapeRequest]): A list of WebscrapeRequest objects.       Returns:     dict: A response object with the status of the scraping job message.--&gt;
     *
     * @param  \Carbon\Model\WebscrapeRequest[] $webscrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeWeb'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function scrapeWebWithHttpInfo($webscrape_request, string $contentType = self::contentTypes['scrapeWeb'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->scrapeWebRequest($webscrape_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->scrapeWebWithHttpInfo(
                        $webscrape_request,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation scrapeWebAsync
     *
     * Web Scrape
     *
     * Conduct a web scrape on a given webpage URL. Our web scraper is fully compatible with JavaScript and supports recursion depth, enabling you to efficiently extract all content from the target website.  &lt;!--Args:     scraping_requests (List[WebscrapeRequest]): A list of WebscrapeRequest objects.       Returns:     dict: A response object with the status of the scraping job message.--&gt;
     *
     * @param  \Carbon\Model\WebscrapeRequest[] $webscrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeWeb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scrapeWebAsync(
        $body,

        string $contentType = self::contentTypes['scrapeWeb'][0]
    )
    {
        $_body = [];
        $webscrape_request = $body === SENTINEL_VALUE ? null : (empty($_body) ? $body : $_body);

        return $this->scrapeWebAsyncWithHttpInfo($webscrape_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation scrapeWebAsyncWithHttpInfo
     *
     * Web Scrape
     *
     * Conduct a web scrape on a given webpage URL. Our web scraper is fully compatible with JavaScript and supports recursion depth, enabling you to efficiently extract all content from the target website.  &lt;!--Args:     scraping_requests (List[WebscrapeRequest]): A list of WebscrapeRequest objects.       Returns:     dict: A response object with the status of the scraping job message.--&gt;
     *
     * @param  \Carbon\Model\WebscrapeRequest[] $webscrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeWeb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function scrapeWebAsyncWithHttpInfo($webscrape_request, string $contentType = self::contentTypes['scrapeWeb'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->scrapeWebRequest($webscrape_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'scrapeWeb'
     *
     * @param  \Carbon\Model\WebscrapeRequest[] $webscrape_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['scrapeWeb'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function scrapeWebRequest($webscrape_request, string $contentType = self::contentTypes['scrapeWeb'][0])
    {

        // verify the required parameter 'webscrape_request' is set
        if ($webscrape_request === SENTINEL_VALUE || (is_array($webscrape_request) && count($webscrape_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter webscrape_request when calling scrapeWeb'
            );
        }


        $resourcePath = '/web_scrape';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($webscrape_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webscrape_request));
            } else {
                $httpBody = $webscrape_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation searchUrls
     *
     * Search Urls
     *
     * Perform a web search and obtain a list of relevant URLs.  As an illustration, when you perform a search for “content related to MRNA,” you will receive a list of links such as the following:      - https://tomrenz.substack.com/p/mrna-and-why-it-matters      - https://www.statnews.com/2020/11/10/the-story-of-mrna-how-a-once-dismissed-idea-became-a-leading-technology-in-the-covid-vaccine-race/      - https://www.statnews.com/2022/11/16/covid-19-vaccines-were-a-success-but-mrna-still-has-a-delivery-problem/          - https://joomi.substack.com/p/were-still-being-misled-about-how  Subsequently, you can submit these links to the web_scrape endpoint in order to retrieve the content of the respective web pages.  Args:     query (str): Query to search for  Returns:     FetchURLsResponse: A response object with a list of URLs for a given search query.
     *
     * @param  string $query query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUrls'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\FetchURLsResponse|\Carbon\Model\HTTPValidationError
     */
    public function searchUrls(
        $query,

        string $contentType = self::contentTypes['searchUrls'][0]
    )
    {

        list($response) = $this->searchUrlsWithHttpInfo($query, $contentType);
        return $response;
    }

    /**
     * Operation searchUrlsWithHttpInfo
     *
     * Search Urls
     *
     * Perform a web search and obtain a list of relevant URLs.  As an illustration, when you perform a search for “content related to MRNA,” you will receive a list of links such as the following:      - https://tomrenz.substack.com/p/mrna-and-why-it-matters      - https://www.statnews.com/2020/11/10/the-story-of-mrna-how-a-once-dismissed-idea-became-a-leading-technology-in-the-covid-vaccine-race/      - https://www.statnews.com/2022/11/16/covid-19-vaccines-were-a-success-but-mrna-still-has-a-delivery-problem/          - https://joomi.substack.com/p/were-still-being-misled-about-how  Subsequently, you can submit these links to the web_scrape endpoint in order to retrieve the content of the respective web pages.  Args:     query (str): Query to search for  Returns:     FetchURLsResponse: A response object with a list of URLs for a given search query.
     *
     * @param  string $query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUrls'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\FetchURLsResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchUrlsWithHttpInfo($query, string $contentType = self::contentTypes['searchUrls'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->searchUrlsRequest($query, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->searchUrlsWithHttpInfo(
                        $query,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\FetchURLsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\FetchURLsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\FetchURLsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\FetchURLsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\FetchURLsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchUrlsAsync
     *
     * Search Urls
     *
     * Perform a web search and obtain a list of relevant URLs.  As an illustration, when you perform a search for “content related to MRNA,” you will receive a list of links such as the following:      - https://tomrenz.substack.com/p/mrna-and-why-it-matters      - https://www.statnews.com/2020/11/10/the-story-of-mrna-how-a-once-dismissed-idea-became-a-leading-technology-in-the-covid-vaccine-race/      - https://www.statnews.com/2022/11/16/covid-19-vaccines-were-a-success-but-mrna-still-has-a-delivery-problem/          - https://joomi.substack.com/p/were-still-being-misled-about-how  Subsequently, you can submit these links to the web_scrape endpoint in order to retrieve the content of the respective web pages.  Args:     query (str): Query to search for  Returns:     FetchURLsResponse: A response object with a list of URLs for a given search query.
     *
     * @param  string $query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchUrlsAsync(
        $query,

        string $contentType = self::contentTypes['searchUrls'][0]
    )
    {

        return $this->searchUrlsAsyncWithHttpInfo($query, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchUrlsAsyncWithHttpInfo
     *
     * Search Urls
     *
     * Perform a web search and obtain a list of relevant URLs.  As an illustration, when you perform a search for “content related to MRNA,” you will receive a list of links such as the following:      - https://tomrenz.substack.com/p/mrna-and-why-it-matters      - https://www.statnews.com/2020/11/10/the-story-of-mrna-how-a-once-dismissed-idea-became-a-leading-technology-in-the-covid-vaccine-race/      - https://www.statnews.com/2022/11/16/covid-19-vaccines-were-a-success-but-mrna-still-has-a-delivery-problem/          - https://joomi.substack.com/p/were-still-being-misled-about-how  Subsequently, you can submit these links to the web_scrape endpoint in order to retrieve the content of the respective web pages.  Args:     query (str): Query to search for  Returns:     FetchURLsResponse: A response object with a list of URLs for a given search query.
     *
     * @param  string $query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchUrlsAsyncWithHttpInfo($query, string $contentType = self::contentTypes['searchUrls'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\FetchURLsResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->searchUrlsRequest($query, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchUrls'
     *
     * @param  string $query (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['searchUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function searchUrlsRequest($query, string $contentType = self::contentTypes['searchUrls'][0])
    {

        // Check if $query is a string
        if ($query !== SENTINEL_VALUE && !is_string($query)) {
            throw new \InvalidArgumentException(sprintf('Invalid value %s, please provide a string, %s given', var_export($query, true), gettype($query)));
        }
        // verify the required parameter 'query' is set
        if ($query === SENTINEL_VALUE || (is_array($query) && count($query) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter query when calling searchUrls'
            );
        }


        $resourcePath = '/search_urls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($query !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $query,
                'query', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? []);
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation userWebpages
     *
     * User Web Pages
     *
     * @param  \Carbon\Model\UserWebPagesRequest $user_web_pages_request user_web_pages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userWebpages'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\Carbon\Model\HTTPValidationError
     */
    public function userWebpages(

        $filters = SENTINEL_VALUE,
        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        string $contentType = self::contentTypes['userWebpages'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $user_web_pages_request = $_body;

        list($response) = $this->userWebpagesWithHttpInfo($user_web_pages_request, $contentType);
        return $response;
    }

    /**
     * Operation userWebpagesWithHttpInfo
     *
     * User Web Pages
     *
     * @param  \Carbon\Model\UserWebPagesRequest $user_web_pages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userWebpages'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function userWebpagesWithHttpInfo($user_web_pages_request, string $contentType = self::contentTypes['userWebpages'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->userWebpagesRequest($user_web_pages_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->userWebpagesWithHttpInfo(
                        $user_web_pages_request,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation userWebpagesAsync
     *
     * User Web Pages
     *
     * @param  \Carbon\Model\UserWebPagesRequest $user_web_pages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userWebpages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userWebpagesAsync(

        $filters = SENTINEL_VALUE,
        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        string $contentType = self::contentTypes['userWebpages'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $user_web_pages_request = $_body;

        return $this->userWebpagesAsyncWithHttpInfo($user_web_pages_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation userWebpagesAsyncWithHttpInfo
     *
     * User Web Pages
     *
     * @param  \Carbon\Model\UserWebPagesRequest $user_web_pages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userWebpages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function userWebpagesAsyncWithHttpInfo($user_web_pages_request, string $contentType = self::contentTypes['userWebpages'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = 'object';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->userWebpagesRequest($user_web_pages_request, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'userWebpages'
     *
     * @param  \Carbon\Model\UserWebPagesRequest $user_web_pages_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['userWebpages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function userWebpagesRequest($user_web_pages_request, string $contentType = self::contentTypes['userWebpages'][0])
    {

        if ($user_web_pages_request !== SENTINEL_VALUE) {
            if (!($user_web_pages_request instanceof \Carbon\Model\UserWebPagesRequest)) {
                if (!is_array($user_web_pages_request))
                    throw new \InvalidArgumentException('"user_web_pages_request" must be associative array or an instance of \Carbon\Model\UserWebPagesRequest UtilitiesApi.userWebpages.');
                else
                    $user_web_pages_request = new \Carbon\Model\UserWebPagesRequest($user_web_pages_request);
            }
        }
        // verify the required parameter 'user_web_pages_request' is set
        if ($user_web_pages_request === SENTINEL_VALUE || (is_array($user_web_pages_request) && count($user_web_pages_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter user_web_pages_request when calling userWebpages'
            );
        }


        $resourcePath = '/user_webpages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_web_pages_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($user_web_pages_request));
            } else {
                $httpBody = $user_web_pages_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
