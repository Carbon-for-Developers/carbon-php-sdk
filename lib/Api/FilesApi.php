<?php
/**
 * FilesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Carbon
 * @author   Konfig
 * @link     https://konfigthis.com
 */

/**
 * Carbon
 *
 * Connect external data to LLMs, no matter the source.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://konfigthis.com
 */


namespace Carbon\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\BodySummarizer;
use GuzzleHttp\Middleware;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Utils;
use Carbon\ApiException;
use Carbon\Configuration;
use Carbon\HeaderSelector;
use Carbon\ObjectSerializer;

class FilesApi extends \Carbon\CustomApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createUserFileTags' => [
            'application/json',
        ],
        'delete' => [
            'application/json',
        ],
        'deleteFileTags' => [
            'application/json',
        ],
        'deleteMany' => [
            'application/json',
        ],
        'deleteV2' => [
            'application/json',
        ],
        'getParsedFile' => [
            'application/json',
        ],
        'getRawFile' => [
            'application/json',
        ],
        'modifyColdStorageParameters' => [
            'application/json',
        ],
        'moveToHotStorage' => [
            'application/json',
        ],
        'queryUserFiles' => [
            'application/json',
        ],
        'queryUserFilesDeprecated' => [
            'application/json',
        ],
        'resync' => [
            'application/json',
        ],
        'upload' => [
            'multipart/form-data',
        ],
        'uploadFromUrl' => [
            'application/json',
        ],
        'uploadText' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $clientOptions = [];
        if (!$config->getVerifySsl()) $clientOptions["verify"] = false;

        // Do not truncate error messages
        // https://github.com/guzzle/guzzle/issues/2185#issuecomment-800293420
        $stack = new HandlerStack(Utils::chooseHandler());
        $stack->push(Middleware::httpErrors(new BodySummarizer(10000)), 'http_errors');
        $stack->push(Middleware::redirect(), 'allow_redirects');
        $stack->push(Middleware::cookies(), 'cookies');
        $stack->push(Middleware::prepareBody(), 'prepare_body');
        $clientOptions["handler"] = $stack;

        $this->client = $client ?: new Client($clientOptions);
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * For initializing request body parameter
     */
    private function setRequestBodyProperty(&$body, $property, $value) {
        if ($body === null) $body = [];
        // user did not pass in a value for this parameter
        if ($value === SENTINEL_VALUE) return;
        $body[$property] = $value;
    }

    /**
     * Operation createUserFileTags
     *
     * Create File Tags
     *
     * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60;. Keys can only be &#x60;string&#x60;. If values other than &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60; are used, they&#39;re automatically converted to strings (e.g. 4 will become \&quot;4\&quot;).
     *
     * @param  \Carbon\Model\OrganizationUserFileTagCreate $organization_user_file_tag_create organization_user_file_tag_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUserFileTags'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError
     */
    public function createUserFileTags(

        $tags,
        $organization_user_file_id,
        string $contentType = self::contentTypes['createUserFileTags'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "tags", $tags);
        $this->setRequestBodyProperty($_body, "organization_user_file_id", $organization_user_file_id);
        $organization_user_file_tag_create = $_body;

        list($response) = $this->createUserFileTagsWithHttpInfo($organization_user_file_tag_create, $contentType);
        return $response;
    }

    /**
     * Operation createUserFileTagsWithHttpInfo
     *
     * Create File Tags
     *
     * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60;. Keys can only be &#x60;string&#x60;. If values other than &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60; are used, they&#39;re automatically converted to strings (e.g. 4 will become \&quot;4\&quot;).
     *
     * @param  \Carbon\Model\OrganizationUserFileTagCreate $organization_user_file_tag_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUserFileTags'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUserFileTagsWithHttpInfo($organization_user_file_tag_create, string $contentType = self::contentTypes['createUserFileTags'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->createUserFileTagsRequest($organization_user_file_tag_create, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->createUserFileTagsWithHttpInfo(
                        $organization_user_file_tag_create,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\UserFile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\UserFile' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\UserFile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\UserFile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\UserFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createUserFileTagsAsync
     *
     * Create File Tags
     *
     * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60;. Keys can only be &#x60;string&#x60;. If values other than &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60; are used, they&#39;re automatically converted to strings (e.g. 4 will become \&quot;4\&quot;).
     *
     * @param  \Carbon\Model\OrganizationUserFileTagCreate $organization_user_file_tag_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUserFileTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUserFileTagsAsync(

        $tags,
        $organization_user_file_id,
        string $contentType = self::contentTypes['createUserFileTags'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "tags", $tags);
        $this->setRequestBodyProperty($_body, "organization_user_file_id", $organization_user_file_id);
        $organization_user_file_tag_create = $_body;

        return $this->createUserFileTagsAsyncWithHttpInfo($organization_user_file_tag_create, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUserFileTagsAsyncWithHttpInfo
     *
     * Create File Tags
     *
     * A tag is a key-value pair that can be added to a file. This pair can then be used for searches (e.g. embedding searches) in order to narrow down the scope of the search. A file can have any number of tags. The following are reserved keys that cannot be used: - db_embedding_id - organization_id - user_id - organization_user_file_id  Carbon currently supports two data types for tag values - &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60;. Keys can only be &#x60;string&#x60;. If values other than &#x60;string&#x60; and &#x60;list&lt;string&gt;&#x60; are used, they&#39;re automatically converted to strings (e.g. 4 will become \&quot;4\&quot;).
     *
     * @param  \Carbon\Model\OrganizationUserFileTagCreate $organization_user_file_tag_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUserFileTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUserFileTagsAsyncWithHttpInfo($organization_user_file_tag_create, string $contentType = self::contentTypes['createUserFileTags'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\UserFile';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->createUserFileTagsRequest($organization_user_file_tag_create, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createUserFileTags'
     *
     * @param  \Carbon\Model\OrganizationUserFileTagCreate $organization_user_file_tag_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUserFileTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createUserFileTagsRequest($organization_user_file_tag_create, string $contentType = self::contentTypes['createUserFileTags'][0])
    {

        if ($organization_user_file_tag_create !== SENTINEL_VALUE) {
            if (!($organization_user_file_tag_create instanceof \Carbon\Model\OrganizationUserFileTagCreate)) {
                if (!is_array($organization_user_file_tag_create))
                    throw new \InvalidArgumentException('"organization_user_file_tag_create" must be associative array or an instance of \Carbon\Model\OrganizationUserFileTagCreate FilesApi.createUserFileTags.');
                else
                    $organization_user_file_tag_create = new \Carbon\Model\OrganizationUserFileTagCreate($organization_user_file_tag_create);
            }
        }
        // verify the required parameter 'organization_user_file_tag_create' is set
        if ($organization_user_file_tag_create === SENTINEL_VALUE || (is_array($organization_user_file_tag_create) && count($organization_user_file_tag_create) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter organization_user_file_tag_create when calling createUserFileTags'
            );
        }


        $resourcePath = '/create_user_file_tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($organization_user_file_tag_create)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($organization_user_file_tag_create));
            } else {
                $httpBody = $organization_user_file_tag_create;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation delete
     *
     * Delete File Endpoint
     *
     * @param  int $file_id file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delete'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\GenericSuccessResponse|\Carbon\Model\HTTPValidationError
     * @deprecated
     */
    public function delete(
        $file_id,

        string $contentType = self::contentTypes['delete'][0]
    )
    {

        list($response) = $this->deleteWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation deleteWithHttpInfo
     *
     * Delete File Endpoint
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delete'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\GenericSuccessResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function deleteWithHttpInfo($file_id, string $contentType = self::contentTypes['delete'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteRequest($file_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->deleteWithHttpInfo(
                        $file_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\GenericSuccessResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\GenericSuccessResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\GenericSuccessResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\GenericSuccessResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\GenericSuccessResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAsync
     *
     * Delete File Endpoint
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function deleteAsync(
        $file_id,

        string $contentType = self::contentTypes['delete'][0]
    )
    {

        return $this->deleteAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAsyncWithHttpInfo
     *
     * Delete File Endpoint
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function deleteAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['delete'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\GenericSuccessResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteRequest($file_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'delete'
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['delete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function deleteRequest($file_id, string $contentType = self::contentTypes['delete'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === SENTINEL_VALUE || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter file_id when calling delete'
            );
        }


        $resourcePath = '/deletefile/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'DELETE';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation deleteFileTags
     *
     * Delete File Tags
     *
     * @param  \Carbon\Model\OrganizationUserFileTagsRemove $organization_user_file_tags_remove organization_user_file_tags_remove (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileTags'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError
     */
    public function deleteFileTags(

        $tags,
        $organization_user_file_id,
        string $contentType = self::contentTypes['deleteFileTags'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "tags", $tags);
        $this->setRequestBodyProperty($_body, "organization_user_file_id", $organization_user_file_id);
        $organization_user_file_tags_remove = $_body;

        list($response) = $this->deleteFileTagsWithHttpInfo($organization_user_file_tags_remove, $contentType);
        return $response;
    }

    /**
     * Operation deleteFileTagsWithHttpInfo
     *
     * Delete File Tags
     *
     * @param  \Carbon\Model\OrganizationUserFileTagsRemove $organization_user_file_tags_remove (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileTags'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileTagsWithHttpInfo($organization_user_file_tags_remove, string $contentType = self::contentTypes['deleteFileTags'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteFileTagsRequest($organization_user_file_tags_remove, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->deleteFileTagsWithHttpInfo(
                        $organization_user_file_tags_remove,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\UserFile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\UserFile' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\UserFile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\UserFile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\UserFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFileTagsAsync
     *
     * Delete File Tags
     *
     * @param  \Carbon\Model\OrganizationUserFileTagsRemove $organization_user_file_tags_remove (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileTagsAsync(

        $tags,
        $organization_user_file_id,
        string $contentType = self::contentTypes['deleteFileTags'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "tags", $tags);
        $this->setRequestBodyProperty($_body, "organization_user_file_id", $organization_user_file_id);
        $organization_user_file_tags_remove = $_body;

        return $this->deleteFileTagsAsyncWithHttpInfo($organization_user_file_tags_remove, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileTagsAsyncWithHttpInfo
     *
     * Delete File Tags
     *
     * @param  \Carbon\Model\OrganizationUserFileTagsRemove $organization_user_file_tags_remove (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileTagsAsyncWithHttpInfo($organization_user_file_tags_remove, string $contentType = self::contentTypes['deleteFileTags'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\UserFile';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteFileTagsRequest($organization_user_file_tags_remove, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFileTags'
     *
     * @param  \Carbon\Model\OrganizationUserFileTagsRemove $organization_user_file_tags_remove (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFileTagsRequest($organization_user_file_tags_remove, string $contentType = self::contentTypes['deleteFileTags'][0])
    {

        if ($organization_user_file_tags_remove !== SENTINEL_VALUE) {
            if (!($organization_user_file_tags_remove instanceof \Carbon\Model\OrganizationUserFileTagsRemove)) {
                if (!is_array($organization_user_file_tags_remove))
                    throw new \InvalidArgumentException('"organization_user_file_tags_remove" must be associative array or an instance of \Carbon\Model\OrganizationUserFileTagsRemove FilesApi.deleteFileTags.');
                else
                    $organization_user_file_tags_remove = new \Carbon\Model\OrganizationUserFileTagsRemove($organization_user_file_tags_remove);
            }
        }
        // verify the required parameter 'organization_user_file_tags_remove' is set
        if ($organization_user_file_tags_remove === SENTINEL_VALUE || (is_array($organization_user_file_tags_remove) && count($organization_user_file_tags_remove) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter organization_user_file_tags_remove when calling deleteFileTags'
            );
        }


        $resourcePath = '/delete_user_file_tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($organization_user_file_tags_remove)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($organization_user_file_tags_remove));
            } else {
                $httpBody = $organization_user_file_tags_remove;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation deleteMany
     *
     * Delete Files Endpoint
     *
     * @param  \Carbon\Model\DeleteFilesQueryInput $delete_files_query_input delete_files_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMany'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\GenericSuccessResponse|\Carbon\Model\HTTPValidationError
     * @deprecated
     */
    public function deleteMany(

        $file_ids = SENTINEL_VALUE,
        $sync_statuses = SENTINEL_VALUE,
        $delete_non_synced_only = false,
        $send_webhook = false,
        $delete_child_files = false,
        string $contentType = self::contentTypes['deleteMany'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "file_ids", $file_ids);
        $this->setRequestBodyProperty($_body, "sync_statuses", $sync_statuses);
        $this->setRequestBodyProperty($_body, "delete_non_synced_only", $delete_non_synced_only);
        $this->setRequestBodyProperty($_body, "send_webhook", $send_webhook);
        $this->setRequestBodyProperty($_body, "delete_child_files", $delete_child_files);
        $delete_files_query_input = $_body;

        list($response) = $this->deleteManyWithHttpInfo($delete_files_query_input, $contentType);
        return $response;
    }

    /**
     * Operation deleteManyWithHttpInfo
     *
     * Delete Files Endpoint
     *
     * @param  \Carbon\Model\DeleteFilesQueryInput $delete_files_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMany'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\GenericSuccessResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function deleteManyWithHttpInfo($delete_files_query_input, string $contentType = self::contentTypes['deleteMany'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteManyRequest($delete_files_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->deleteManyWithHttpInfo(
                        $delete_files_query_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\GenericSuccessResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\GenericSuccessResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\GenericSuccessResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\GenericSuccessResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\GenericSuccessResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteManyAsync
     *
     * Delete Files Endpoint
     *
     * @param  \Carbon\Model\DeleteFilesQueryInput $delete_files_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function deleteManyAsync(

        $file_ids = SENTINEL_VALUE,
        $sync_statuses = SENTINEL_VALUE,
        $delete_non_synced_only = false,
        $send_webhook = false,
        $delete_child_files = false,
        string $contentType = self::contentTypes['deleteMany'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "file_ids", $file_ids);
        $this->setRequestBodyProperty($_body, "sync_statuses", $sync_statuses);
        $this->setRequestBodyProperty($_body, "delete_non_synced_only", $delete_non_synced_only);
        $this->setRequestBodyProperty($_body, "send_webhook", $send_webhook);
        $this->setRequestBodyProperty($_body, "delete_child_files", $delete_child_files);
        $delete_files_query_input = $_body;

        return $this->deleteManyAsyncWithHttpInfo($delete_files_query_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteManyAsyncWithHttpInfo
     *
     * Delete Files Endpoint
     *
     * @param  \Carbon\Model\DeleteFilesQueryInput $delete_files_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function deleteManyAsyncWithHttpInfo($delete_files_query_input, string $contentType = self::contentTypes['deleteMany'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\GenericSuccessResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteManyRequest($delete_files_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMany'
     *
     * @param  \Carbon\Model\DeleteFilesQueryInput $delete_files_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteMany'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function deleteManyRequest($delete_files_query_input, string $contentType = self::contentTypes['deleteMany'][0])
    {

        if ($delete_files_query_input !== SENTINEL_VALUE) {
            if (!($delete_files_query_input instanceof \Carbon\Model\DeleteFilesQueryInput)) {
                if (!is_array($delete_files_query_input))
                    throw new \InvalidArgumentException('"delete_files_query_input" must be associative array or an instance of \Carbon\Model\DeleteFilesQueryInput FilesApi.deleteMany.');
                else
                    $delete_files_query_input = new \Carbon\Model\DeleteFilesQueryInput($delete_files_query_input);
            }
        }
        // verify the required parameter 'delete_files_query_input' is set
        if ($delete_files_query_input === SENTINEL_VALUE || (is_array($delete_files_query_input) && count($delete_files_query_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter delete_files_query_input when calling deleteMany'
            );
        }


        $resourcePath = '/delete_files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($delete_files_query_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($delete_files_query_input));
            } else {
                $httpBody = $delete_files_query_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation deleteV2
     *
     * Delete Files V2 Endpoint
     *
     * @param  \Carbon\Model\DeleteFilesV2QueryInput $delete_files_v2_query_input delete_files_v2_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteV2'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\GenericSuccessResponse|\Carbon\Model\HTTPValidationError
     */
    public function deleteV2(

        $filters = SENTINEL_VALUE,
        $send_webhook = false,
        $preserve_file_record = false,
        string $contentType = self::contentTypes['deleteV2'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "send_webhook", $send_webhook);
        $this->setRequestBodyProperty($_body, "preserve_file_record", $preserve_file_record);
        $delete_files_v2_query_input = $_body;

        list($response) = $this->deleteV2WithHttpInfo($delete_files_v2_query_input, $contentType);
        return $response;
    }

    /**
     * Operation deleteV2WithHttpInfo
     *
     * Delete Files V2 Endpoint
     *
     * @param  \Carbon\Model\DeleteFilesV2QueryInput $delete_files_v2_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteV2'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\GenericSuccessResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteV2WithHttpInfo($delete_files_v2_query_input, string $contentType = self::contentTypes['deleteV2'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteV2Request($delete_files_v2_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->deleteV2WithHttpInfo(
                        $delete_files_v2_query_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\GenericSuccessResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\GenericSuccessResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\GenericSuccessResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\GenericSuccessResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\GenericSuccessResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteV2Async
     *
     * Delete Files V2 Endpoint
     *
     * @param  \Carbon\Model\DeleteFilesV2QueryInput $delete_files_v2_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV2Async(

        $filters = SENTINEL_VALUE,
        $send_webhook = false,
        $preserve_file_record = false,
        string $contentType = self::contentTypes['deleteV2'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "send_webhook", $send_webhook);
        $this->setRequestBodyProperty($_body, "preserve_file_record", $preserve_file_record);
        $delete_files_v2_query_input = $_body;

        return $this->deleteV2AsyncWithHttpInfo($delete_files_v2_query_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteV2AsyncWithHttpInfo
     *
     * Delete Files V2 Endpoint
     *
     * @param  \Carbon\Model\DeleteFilesV2QueryInput $delete_files_v2_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteV2AsyncWithHttpInfo($delete_files_v2_query_input, string $contentType = self::contentTypes['deleteV2'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\GenericSuccessResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->deleteV2Request($delete_files_v2_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteV2'
     *
     * @param  \Carbon\Model\DeleteFilesV2QueryInput $delete_files_v2_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteV2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteV2Request($delete_files_v2_query_input, string $contentType = self::contentTypes['deleteV2'][0])
    {

        if ($delete_files_v2_query_input !== SENTINEL_VALUE) {
            if (!($delete_files_v2_query_input instanceof \Carbon\Model\DeleteFilesV2QueryInput)) {
                if (!is_array($delete_files_v2_query_input))
                    throw new \InvalidArgumentException('"delete_files_v2_query_input" must be associative array or an instance of \Carbon\Model\DeleteFilesV2QueryInput FilesApi.deleteV2.');
                else
                    $delete_files_v2_query_input = new \Carbon\Model\DeleteFilesV2QueryInput($delete_files_v2_query_input);
            }
        }
        // verify the required parameter 'delete_files_v2_query_input' is set
        if ($delete_files_v2_query_input === SENTINEL_VALUE || (is_array($delete_files_v2_query_input) && count($delete_files_v2_query_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter delete_files_v2_query_input when calling deleteV2'
            );
        }


        $resourcePath = '/delete_files_v2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($delete_files_v2_query_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($delete_files_v2_query_input));
            } else {
                $httpBody = $delete_files_v2_query_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getParsedFile
     *
     * Parsed File
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  int $file_id file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getParsedFile'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\PresignedURLResponse|\Carbon\Model\HTTPValidationError
     * @deprecated
     */
    public function getParsedFile(
        $file_id,

        string $contentType = self::contentTypes['getParsedFile'][0]
    )
    {

        list($response) = $this->getParsedFileWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation getParsedFileWithHttpInfo
     *
     * Parsed File
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getParsedFile'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\PresignedURLResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getParsedFileWithHttpInfo($file_id, string $contentType = self::contentTypes['getParsedFile'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getParsedFileRequest($file_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getParsedFileWithHttpInfo(
                        $file_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\PresignedURLResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\PresignedURLResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\PresignedURLResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\PresignedURLResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\PresignedURLResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getParsedFileAsync
     *
     * Parsed File
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getParsedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getParsedFileAsync(
        $file_id,

        string $contentType = self::contentTypes['getParsedFile'][0]
    )
    {

        return $this->getParsedFileAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getParsedFileAsyncWithHttpInfo
     *
     * Parsed File
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getParsedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getParsedFileAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['getParsedFile'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\PresignedURLResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getParsedFileRequest($file_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getParsedFile'
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getParsedFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getParsedFileRequest($file_id, string $contentType = self::contentTypes['getParsedFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === SENTINEL_VALUE || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter file_id when calling getParsedFile'
            );
        }


        $resourcePath = '/parsed_file/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getRawFile
     *
     * Raw File
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  int $file_id file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRawFile'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\PresignedURLResponse|\Carbon\Model\HTTPValidationError
     * @deprecated
     */
    public function getRawFile(
        $file_id,

        string $contentType = self::contentTypes['getRawFile'][0]
    )
    {

        list($response) = $this->getRawFileWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation getRawFileWithHttpInfo
     *
     * Raw File
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRawFile'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\PresignedURLResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getRawFileWithHttpInfo($file_id, string $contentType = self::contentTypes['getRawFile'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getRawFileRequest($file_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getRawFileWithHttpInfo(
                        $file_id,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\PresignedURLResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\PresignedURLResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\PresignedURLResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\PresignedURLResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\PresignedURLResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRawFileAsync
     *
     * Raw File
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRawFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getRawFileAsync(
        $file_id,

        string $contentType = self::contentTypes['getRawFile'][0]
    )
    {

        return $this->getRawFileAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRawFileAsyncWithHttpInfo
     *
     * Raw File
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRawFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getRawFileAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['getRawFile'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\PresignedURLResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getRawFileRequest($file_id, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRawFile'
     *
     * @param  int $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRawFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getRawFileRequest($file_id, string $contentType = self::contentTypes['getRawFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === SENTINEL_VALUE || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter file_id when calling getRawFile'
            );
        }


        $resourcePath = '/raw_file/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== SENTINEL_VALUE) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'GET';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation modifyColdStorageParameters
     *
     * Modify Cold Storage Parameters
     *
     * @param  \Carbon\Model\ModifyColdStorageParametersQueryInput $modify_cold_storage_parameters_query_input modify_cold_storage_parameters_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyColdStorageParameters'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool|\Carbon\Model\HTTPValidationError
     */
    public function modifyColdStorageParameters(

        $filters = SENTINEL_VALUE,
        $enable_cold_storage = SENTINEL_VALUE,
        $hot_storage_time_to_live = SENTINEL_VALUE,
        string $contentType = self::contentTypes['modifyColdStorageParameters'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "enable_cold_storage", $enable_cold_storage);
        $this->setRequestBodyProperty($_body, "hot_storage_time_to_live", $hot_storage_time_to_live);
        $modify_cold_storage_parameters_query_input = $_body;

        list($response) = $this->modifyColdStorageParametersWithHttpInfo($modify_cold_storage_parameters_query_input, $contentType);
        return $response;
    }

    /**
     * Operation modifyColdStorageParametersWithHttpInfo
     *
     * Modify Cold Storage Parameters
     *
     * @param  \Carbon\Model\ModifyColdStorageParametersQueryInput $modify_cold_storage_parameters_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyColdStorageParameters'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function modifyColdStorageParametersWithHttpInfo($modify_cold_storage_parameters_query_input, string $contentType = self::contentTypes['modifyColdStorageParameters'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->modifyColdStorageParametersRequest($modify_cold_storage_parameters_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->modifyColdStorageParametersWithHttpInfo(
                        $modify_cold_storage_parameters_query_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modifyColdStorageParametersAsync
     *
     * Modify Cold Storage Parameters
     *
     * @param  \Carbon\Model\ModifyColdStorageParametersQueryInput $modify_cold_storage_parameters_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyColdStorageParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyColdStorageParametersAsync(

        $filters = SENTINEL_VALUE,
        $enable_cold_storage = SENTINEL_VALUE,
        $hot_storage_time_to_live = SENTINEL_VALUE,
        string $contentType = self::contentTypes['modifyColdStorageParameters'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "enable_cold_storage", $enable_cold_storage);
        $this->setRequestBodyProperty($_body, "hot_storage_time_to_live", $hot_storage_time_to_live);
        $modify_cold_storage_parameters_query_input = $_body;

        return $this->modifyColdStorageParametersAsyncWithHttpInfo($modify_cold_storage_parameters_query_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modifyColdStorageParametersAsyncWithHttpInfo
     *
     * Modify Cold Storage Parameters
     *
     * @param  \Carbon\Model\ModifyColdStorageParametersQueryInput $modify_cold_storage_parameters_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyColdStorageParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyColdStorageParametersAsyncWithHttpInfo($modify_cold_storage_parameters_query_input, string $contentType = self::contentTypes['modifyColdStorageParameters'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = 'bool';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->modifyColdStorageParametersRequest($modify_cold_storage_parameters_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modifyColdStorageParameters'
     *
     * @param  \Carbon\Model\ModifyColdStorageParametersQueryInput $modify_cold_storage_parameters_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['modifyColdStorageParameters'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function modifyColdStorageParametersRequest($modify_cold_storage_parameters_query_input, string $contentType = self::contentTypes['modifyColdStorageParameters'][0])
    {

        if ($modify_cold_storage_parameters_query_input !== SENTINEL_VALUE) {
            if (!($modify_cold_storage_parameters_query_input instanceof \Carbon\Model\ModifyColdStorageParametersQueryInput)) {
                if (!is_array($modify_cold_storage_parameters_query_input))
                    throw new \InvalidArgumentException('"modify_cold_storage_parameters_query_input" must be associative array or an instance of \Carbon\Model\ModifyColdStorageParametersQueryInput FilesApi.modifyColdStorageParameters.');
                else
                    $modify_cold_storage_parameters_query_input = new \Carbon\Model\ModifyColdStorageParametersQueryInput($modify_cold_storage_parameters_query_input);
            }
        }
        // verify the required parameter 'modify_cold_storage_parameters_query_input' is set
        if ($modify_cold_storage_parameters_query_input === SENTINEL_VALUE || (is_array($modify_cold_storage_parameters_query_input) && count($modify_cold_storage_parameters_query_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter modify_cold_storage_parameters_query_input when calling modifyColdStorageParameters'
            );
        }


        $resourcePath = '/modify_cold_storage_parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($modify_cold_storage_parameters_query_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($modify_cold_storage_parameters_query_input));
            } else {
                $httpBody = $modify_cold_storage_parameters_query_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation moveToHotStorage
     *
     * Move To Hot Storage
     *
     * @param  \Carbon\Model\MoveToHotStorageQueryInput $move_to_hot_storage_query_input move_to_hot_storage_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveToHotStorage'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool|\Carbon\Model\HTTPValidationError
     */
    public function moveToHotStorage(

        $filters = SENTINEL_VALUE,
        string $contentType = self::contentTypes['moveToHotStorage'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $move_to_hot_storage_query_input = $_body;

        list($response) = $this->moveToHotStorageWithHttpInfo($move_to_hot_storage_query_input, $contentType);
        return $response;
    }

    /**
     * Operation moveToHotStorageWithHttpInfo
     *
     * Move To Hot Storage
     *
     * @param  \Carbon\Model\MoveToHotStorageQueryInput $move_to_hot_storage_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveToHotStorage'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveToHotStorageWithHttpInfo($move_to_hot_storage_query_input, string $contentType = self::contentTypes['moveToHotStorage'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->moveToHotStorageRequest($move_to_hot_storage_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->moveToHotStorageWithHttpInfo(
                        $move_to_hot_storage_query_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation moveToHotStorageAsync
     *
     * Move To Hot Storage
     *
     * @param  \Carbon\Model\MoveToHotStorageQueryInput $move_to_hot_storage_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveToHotStorage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveToHotStorageAsync(

        $filters = SENTINEL_VALUE,
        string $contentType = self::contentTypes['moveToHotStorage'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $move_to_hot_storage_query_input = $_body;

        return $this->moveToHotStorageAsyncWithHttpInfo($move_to_hot_storage_query_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveToHotStorageAsyncWithHttpInfo
     *
     * Move To Hot Storage
     *
     * @param  \Carbon\Model\MoveToHotStorageQueryInput $move_to_hot_storage_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveToHotStorage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveToHotStorageAsyncWithHttpInfo($move_to_hot_storage_query_input, string $contentType = self::contentTypes['moveToHotStorage'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = 'bool';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->moveToHotStorageRequest($move_to_hot_storage_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'moveToHotStorage'
     *
     * @param  \Carbon\Model\MoveToHotStorageQueryInput $move_to_hot_storage_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveToHotStorage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function moveToHotStorageRequest($move_to_hot_storage_query_input, string $contentType = self::contentTypes['moveToHotStorage'][0])
    {

        if ($move_to_hot_storage_query_input !== SENTINEL_VALUE) {
            if (!($move_to_hot_storage_query_input instanceof \Carbon\Model\MoveToHotStorageQueryInput)) {
                if (!is_array($move_to_hot_storage_query_input))
                    throw new \InvalidArgumentException('"move_to_hot_storage_query_input" must be associative array or an instance of \Carbon\Model\MoveToHotStorageQueryInput FilesApi.moveToHotStorage.');
                else
                    $move_to_hot_storage_query_input = new \Carbon\Model\MoveToHotStorageQueryInput($move_to_hot_storage_query_input);
            }
        }
        // verify the required parameter 'move_to_hot_storage_query_input' is set
        if ($move_to_hot_storage_query_input === SENTINEL_VALUE || (is_array($move_to_hot_storage_query_input) && count($move_to_hot_storage_query_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter move_to_hot_storage_query_input when calling moveToHotStorage'
            );
        }


        $resourcePath = '/move_to_hot_storage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($move_to_hot_storage_query_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($move_to_hot_storage_query_input));
            } else {
                $httpBody = $move_to_hot_storage_query_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation queryUserFiles
     *
     * User Files V2
     *
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFiles'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\UserFilesV2|\Carbon\Model\HTTPValidationError
     */
    public function queryUserFiles(

        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        $filters = SENTINEL_VALUE,
        $include_raw_file = SENTINEL_VALUE,
        $include_parsed_text_file = SENTINEL_VALUE,
        $include_additional_files = SENTINEL_VALUE,
        string $contentType = self::contentTypes['queryUserFiles'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "include_raw_file", $include_raw_file);
        $this->setRequestBodyProperty($_body, "include_parsed_text_file", $include_parsed_text_file);
        $this->setRequestBodyProperty($_body, "include_additional_files", $include_additional_files);
        $organization_user_files_to_sync_query_input = $_body;

        list($response) = $this->queryUserFilesWithHttpInfo($organization_user_files_to_sync_query_input, $contentType);
        return $response;
    }

    /**
     * Operation queryUserFilesWithHttpInfo
     *
     * User Files V2
     *
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFiles'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\UserFilesV2|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryUserFilesWithHttpInfo($organization_user_files_to_sync_query_input, string $contentType = self::contentTypes['queryUserFiles'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->queryUserFilesRequest($organization_user_files_to_sync_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->queryUserFilesWithHttpInfo(
                        $organization_user_files_to_sync_query_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\UserFilesV2' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\UserFilesV2' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\UserFilesV2', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\UserFilesV2';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\UserFilesV2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryUserFilesAsync
     *
     * User Files V2
     *
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryUserFilesAsync(

        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        $filters = SENTINEL_VALUE,
        $include_raw_file = SENTINEL_VALUE,
        $include_parsed_text_file = SENTINEL_VALUE,
        $include_additional_files = SENTINEL_VALUE,
        string $contentType = self::contentTypes['queryUserFiles'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "include_raw_file", $include_raw_file);
        $this->setRequestBodyProperty($_body, "include_parsed_text_file", $include_parsed_text_file);
        $this->setRequestBodyProperty($_body, "include_additional_files", $include_additional_files);
        $organization_user_files_to_sync_query_input = $_body;

        return $this->queryUserFilesAsyncWithHttpInfo($organization_user_files_to_sync_query_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryUserFilesAsyncWithHttpInfo
     *
     * User Files V2
     *
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryUserFilesAsyncWithHttpInfo($organization_user_files_to_sync_query_input, string $contentType = self::contentTypes['queryUserFiles'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\UserFilesV2';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->queryUserFilesRequest($organization_user_files_to_sync_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryUserFiles'
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function queryUserFilesRequest($organization_user_files_to_sync_query_input, string $contentType = self::contentTypes['queryUserFiles'][0])
    {

        if ($organization_user_files_to_sync_query_input !== SENTINEL_VALUE) {
            if (!($organization_user_files_to_sync_query_input instanceof \Carbon\Model\OrganizationUserFilesToSyncQueryInput)) {
                if (!is_array($organization_user_files_to_sync_query_input))
                    throw new \InvalidArgumentException('"organization_user_files_to_sync_query_input" must be associative array or an instance of \Carbon\Model\OrganizationUserFilesToSyncQueryInput FilesApi.queryUserFiles.');
                else
                    $organization_user_files_to_sync_query_input = new \Carbon\Model\OrganizationUserFilesToSyncQueryInput($organization_user_files_to_sync_query_input);
            }
        }
        // verify the required parameter 'organization_user_files_to_sync_query_input' is set
        if ($organization_user_files_to_sync_query_input === SENTINEL_VALUE || (is_array($organization_user_files_to_sync_query_input) && count($organization_user_files_to_sync_query_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter organization_user_files_to_sync_query_input when calling queryUserFiles'
            );
        }


        $resourcePath = '/user_files_v2';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($organization_user_files_to_sync_query_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($organization_user_files_to_sync_query_input));
            } else {
                $httpBody = $organization_user_files_to_sync_query_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation queryUserFilesDeprecated
     *
     * User Files
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFilesDeprecated'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\UserFile[]|\Carbon\Model\HTTPValidationError
     * @deprecated
     */
    public function queryUserFilesDeprecated(

        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        $filters = SENTINEL_VALUE,
        $include_raw_file = SENTINEL_VALUE,
        $include_parsed_text_file = SENTINEL_VALUE,
        $include_additional_files = SENTINEL_VALUE,
        string $contentType = self::contentTypes['queryUserFilesDeprecated'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "include_raw_file", $include_raw_file);
        $this->setRequestBodyProperty($_body, "include_parsed_text_file", $include_parsed_text_file);
        $this->setRequestBodyProperty($_body, "include_additional_files", $include_additional_files);
        $organization_user_files_to_sync_query_input = $_body;

        list($response) = $this->queryUserFilesDeprecatedWithHttpInfo($organization_user_files_to_sync_query_input, $contentType);
        return $response;
    }

    /**
     * Operation queryUserFilesDeprecatedWithHttpInfo
     *
     * User Files
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFilesDeprecated'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\UserFile[]|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function queryUserFilesDeprecatedWithHttpInfo($organization_user_files_to_sync_query_input, string $contentType = self::contentTypes['queryUserFilesDeprecated'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->queryUserFilesDeprecatedRequest($organization_user_files_to_sync_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->queryUserFilesDeprecatedWithHttpInfo(
                        $organization_user_files_to_sync_query_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\UserFile[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\UserFile[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\UserFile[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\UserFile[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\UserFile[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryUserFilesDeprecatedAsync
     *
     * User Files
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFilesDeprecated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function queryUserFilesDeprecatedAsync(

        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        $filters = SENTINEL_VALUE,
        $include_raw_file = SENTINEL_VALUE,
        $include_parsed_text_file = SENTINEL_VALUE,
        $include_additional_files = SENTINEL_VALUE,
        string $contentType = self::contentTypes['queryUserFilesDeprecated'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "include_raw_file", $include_raw_file);
        $this->setRequestBodyProperty($_body, "include_parsed_text_file", $include_parsed_text_file);
        $this->setRequestBodyProperty($_body, "include_additional_files", $include_additional_files);
        $organization_user_files_to_sync_query_input = $_body;

        return $this->queryUserFilesDeprecatedAsyncWithHttpInfo($organization_user_files_to_sync_query_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryUserFilesDeprecatedAsyncWithHttpInfo
     *
     * User Files
     *
     * This route is deprecated. Use &#x60;/user_files_v2&#x60; instead.
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFilesDeprecated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function queryUserFilesDeprecatedAsyncWithHttpInfo($organization_user_files_to_sync_query_input, string $contentType = self::contentTypes['queryUserFilesDeprecated'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\UserFile[]';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->queryUserFilesDeprecatedRequest($organization_user_files_to_sync_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryUserFilesDeprecated'
     *
     * @param  \Carbon\Model\OrganizationUserFilesToSyncQueryInput $organization_user_files_to_sync_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['queryUserFilesDeprecated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function queryUserFilesDeprecatedRequest($organization_user_files_to_sync_query_input, string $contentType = self::contentTypes['queryUserFilesDeprecated'][0])
    {

        if ($organization_user_files_to_sync_query_input !== SENTINEL_VALUE) {
            if (!($organization_user_files_to_sync_query_input instanceof \Carbon\Model\OrganizationUserFilesToSyncQueryInput)) {
                if (!is_array($organization_user_files_to_sync_query_input))
                    throw new \InvalidArgumentException('"organization_user_files_to_sync_query_input" must be associative array or an instance of \Carbon\Model\OrganizationUserFilesToSyncQueryInput FilesApi.queryUserFilesDeprecated.');
                else
                    $organization_user_files_to_sync_query_input = new \Carbon\Model\OrganizationUserFilesToSyncQueryInput($organization_user_files_to_sync_query_input);
            }
        }
        // verify the required parameter 'organization_user_files_to_sync_query_input' is set
        if ($organization_user_files_to_sync_query_input === SENTINEL_VALUE || (is_array($organization_user_files_to_sync_query_input) && count($organization_user_files_to_sync_query_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter organization_user_files_to_sync_query_input when calling queryUserFilesDeprecated'
            );
        }


        $resourcePath = '/user_files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($organization_user_files_to_sync_query_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($organization_user_files_to_sync_query_input));
            } else {
                $httpBody = $organization_user_files_to_sync_query_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation resync
     *
     * Resync File
     *
     * @param  \Carbon\Model\ResyncFileQueryInput $resync_file_query_input resync_file_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resync'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError
     */
    public function resync(

        $file_id,
        $chunk_size = SENTINEL_VALUE,
        $chunk_overlap = SENTINEL_VALUE,
        $force_embedding_generation = false,
        string $contentType = self::contentTypes['resync'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "file_id", $file_id);
        $this->setRequestBodyProperty($_body, "chunk_size", $chunk_size);
        $this->setRequestBodyProperty($_body, "chunk_overlap", $chunk_overlap);
        $this->setRequestBodyProperty($_body, "force_embedding_generation", $force_embedding_generation);
        $resync_file_query_input = $_body;

        list($response) = $this->resyncWithHttpInfo($resync_file_query_input, $contentType);
        return $response;
    }

    /**
     * Operation resyncWithHttpInfo
     *
     * Resync File
     *
     * @param  \Carbon\Model\ResyncFileQueryInput $resync_file_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resync'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function resyncWithHttpInfo($resync_file_query_input, string $contentType = self::contentTypes['resync'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->resyncRequest($resync_file_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->resyncWithHttpInfo(
                        $resync_file_query_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\UserFile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\UserFile' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\UserFile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\UserFile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\UserFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resyncAsync
     *
     * Resync File
     *
     * @param  \Carbon\Model\ResyncFileQueryInput $resync_file_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resyncAsync(

        $file_id,
        $chunk_size = SENTINEL_VALUE,
        $chunk_overlap = SENTINEL_VALUE,
        $force_embedding_generation = false,
        string $contentType = self::contentTypes['resync'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "file_id", $file_id);
        $this->setRequestBodyProperty($_body, "chunk_size", $chunk_size);
        $this->setRequestBodyProperty($_body, "chunk_overlap", $chunk_overlap);
        $this->setRequestBodyProperty($_body, "force_embedding_generation", $force_embedding_generation);
        $resync_file_query_input = $_body;

        return $this->resyncAsyncWithHttpInfo($resync_file_query_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resyncAsyncWithHttpInfo
     *
     * Resync File
     *
     * @param  \Carbon\Model\ResyncFileQueryInput $resync_file_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resyncAsyncWithHttpInfo($resync_file_query_input, string $contentType = self::contentTypes['resync'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\UserFile';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->resyncRequest($resync_file_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resync'
     *
     * @param  \Carbon\Model\ResyncFileQueryInput $resync_file_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resyncRequest($resync_file_query_input, string $contentType = self::contentTypes['resync'][0])
    {

        if ($resync_file_query_input !== SENTINEL_VALUE) {
            if (!($resync_file_query_input instanceof \Carbon\Model\ResyncFileQueryInput)) {
                if (!is_array($resync_file_query_input))
                    throw new \InvalidArgumentException('"resync_file_query_input" must be associative array or an instance of \Carbon\Model\ResyncFileQueryInput FilesApi.resync.');
                else
                    $resync_file_query_input = new \Carbon\Model\ResyncFileQueryInput($resync_file_query_input);
            }
        }
        // verify the required parameter 'resync_file_query_input' is set
        if ($resync_file_query_input === SENTINEL_VALUE || (is_array($resync_file_query_input) && count($resync_file_query_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter resync_file_query_input when calling resync'
            );
        }


        $resourcePath = '/resync_file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resync_file_query_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($resync_file_query_input));
            } else {
                $httpBody = $resync_file_query_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation upload
     *
     * Create Upload File
     *
     * This endpoint is used to directly upload local files to Carbon. The &#x60;POST&#x60; request should be a multipart form request. Note that the &#x60;set_page_as_boundary&#x60; query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - &#x60;chunk_size&#x60;: the chunk size (in tokens) applied when splitting the document - &#x60;chunk_overlap&#x60;: the chunk overlap (in tokens) applied when splitting the document - &#x60;skip_embedding_generation&#x60;: whether or not to skip the generation of chunks and embeddings - &#x60;set_page_as_boundary&#x60;: described above - &#x60;embedding_model&#x60;: the model used to generate embeddings for the document chunks - &#x60;use_ocr&#x60;: whether or not to use OCR as a preprocessing step prior to generating chunks. Valid for PDFs, JPEGs, and PNGs - &#x60;generate_sparse_vectors&#x60;: whether or not to generate sparse vectors for the file. Required for hybrid search. - &#x60;prepend_filename_to_chunks&#x60;: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \SplFileObject $file file (required)
     * @param  \Carbon\Model\BodyCreateUploadFileUploadfilePost $body_create_upload_file_uploadfile_post body_create_upload_file_uploadfile_post (required)
     * @param  int $chunk_size Chunk size in tiktoken tokens to be used when processing file. (optional)
     * @param  int $chunk_overlap Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     * @param  bool $skip_embedding_generation Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     * @param  bool $set_page_as_boundary Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     * @param  EmbeddingModel $embedding_model Embedding model that will be used to embed file chunks. (optional)
     * @param  bool $use_ocr Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     * @param  bool $generate_sparse_vectors Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     * @param  bool $prepend_filename_to_chunks Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     * @param  int $max_items_per_chunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     * @param  bool $parse_pdf_tables_with_ocr Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     * @param  bool $detect_audio_language Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     * @param  TranscriptionServiceNullable $transcription_service The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     * @param  bool $include_speaker_labels Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     * @param  FileContentTypesNullable $media_type The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     * @param  bool $split_rows Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     * @param  bool $enable_cold_storage Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     * @param  int $hot_storage_time_to_live Time in seconds after which the file will be moved to cold storage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['upload'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError
     */
    public function upload(

        $file,
        $chunk_size = SENTINEL_VALUE,
        $chunk_overlap = SENTINEL_VALUE,
        $skip_embedding_generation = false,
        $set_page_as_boundary = false,
        $embedding_model = SENTINEL_VALUE,
        $use_ocr = false,
        $generate_sparse_vectors = false,
        $prepend_filename_to_chunks = false,
        $max_items_per_chunk = SENTINEL_VALUE,
        $parse_pdf_tables_with_ocr = false,
        $detect_audio_language = false,
        $transcription_service = SENTINEL_VALUE,
        $include_speaker_labels = false,
        $media_type = SENTINEL_VALUE,
        $split_rows = false,
        $enable_cold_storage = false,
        $hot_storage_time_to_live = SENTINEL_VALUE,
        string $contentType = self::contentTypes['upload'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "file", $file);
        $body_create_upload_file_uploadfile_post = $_body;

        list($response) = $this->uploadWithHttpInfo($file, $body_create_upload_file_uploadfile_post, $chunk_size, $chunk_overlap, $skip_embedding_generation, $set_page_as_boundary, $embedding_model, $use_ocr, $generate_sparse_vectors, $prepend_filename_to_chunks, $max_items_per_chunk, $parse_pdf_tables_with_ocr, $detect_audio_language, $transcription_service, $include_speaker_labels, $media_type, $split_rows, $enable_cold_storage, $hot_storage_time_to_live, $contentType);
        return $response;
    }

    /**
     * Operation uploadWithHttpInfo
     *
     * Create Upload File
     *
     * This endpoint is used to directly upload local files to Carbon. The &#x60;POST&#x60; request should be a multipart form request. Note that the &#x60;set_page_as_boundary&#x60; query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - &#x60;chunk_size&#x60;: the chunk size (in tokens) applied when splitting the document - &#x60;chunk_overlap&#x60;: the chunk overlap (in tokens) applied when splitting the document - &#x60;skip_embedding_generation&#x60;: whether or not to skip the generation of chunks and embeddings - &#x60;set_page_as_boundary&#x60;: described above - &#x60;embedding_model&#x60;: the model used to generate embeddings for the document chunks - &#x60;use_ocr&#x60;: whether or not to use OCR as a preprocessing step prior to generating chunks. Valid for PDFs, JPEGs, and PNGs - &#x60;generate_sparse_vectors&#x60;: whether or not to generate sparse vectors for the file. Required for hybrid search. - &#x60;prepend_filename_to_chunks&#x60;: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \SplFileObject $file (required)
     * @param  \Carbon\Model\BodyCreateUploadFileUploadfilePost $body_create_upload_file_uploadfile_post (required)
     * @param  int $chunk_size Chunk size in tiktoken tokens to be used when processing file. (optional)
     * @param  int $chunk_overlap Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     * @param  bool $skip_embedding_generation Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     * @param  bool $set_page_as_boundary Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     * @param  EmbeddingModel $embedding_model Embedding model that will be used to embed file chunks. (optional)
     * @param  bool $use_ocr Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     * @param  bool $generate_sparse_vectors Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     * @param  bool $prepend_filename_to_chunks Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     * @param  int $max_items_per_chunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     * @param  bool $parse_pdf_tables_with_ocr Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     * @param  bool $detect_audio_language Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     * @param  TranscriptionServiceNullable $transcription_service The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     * @param  bool $include_speaker_labels Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     * @param  FileContentTypesNullable $media_type The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     * @param  bool $split_rows Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     * @param  bool $enable_cold_storage Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     * @param  int $hot_storage_time_to_live Time in seconds after which the file will be moved to cold storage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['upload'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadWithHttpInfo($file, $body_create_upload_file_uploadfile_post, $chunk_size = null, $chunk_overlap = null, $skip_embedding_generation = false, $set_page_as_boundary = false, $embedding_model = null, $use_ocr = false, $generate_sparse_vectors = false, $prepend_filename_to_chunks = false, $max_items_per_chunk = null, $parse_pdf_tables_with_ocr = false, $detect_audio_language = false, $transcription_service = null, $include_speaker_labels = false, $media_type = null, $split_rows = false, $enable_cold_storage = false, $hot_storage_time_to_live = null, string $contentType = self::contentTypes['upload'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->uploadRequest($file, $body_create_upload_file_uploadfile_post, $chunk_size, $chunk_overlap, $skip_embedding_generation, $set_page_as_boundary, $embedding_model, $use_ocr, $generate_sparse_vectors, $prepend_filename_to_chunks, $max_items_per_chunk, $parse_pdf_tables_with_ocr, $detect_audio_language, $transcription_service, $include_speaker_labels, $media_type, $split_rows, $enable_cold_storage, $hot_storage_time_to_live, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->uploadWithHttpInfo(
                        $file,
                        $body_create_upload_file_uploadfile_post,
                        $chunk_size,
                        $chunk_overlap,
                        $skip_embedding_generation,
                        $set_page_as_boundary,
                        $embedding_model,
                        $use_ocr,
                        $generate_sparse_vectors,
                        $prepend_filename_to_chunks,
                        $max_items_per_chunk,
                        $parse_pdf_tables_with_ocr,
                        $detect_audio_language,
                        $transcription_service,
                        $include_speaker_labels,
                        $media_type,
                        $split_rows,
                        $enable_cold_storage,
                        $hot_storage_time_to_live,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\UserFile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\UserFile' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\UserFile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\UserFile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\UserFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadAsync
     *
     * Create Upload File
     *
     * This endpoint is used to directly upload local files to Carbon. The &#x60;POST&#x60; request should be a multipart form request. Note that the &#x60;set_page_as_boundary&#x60; query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - &#x60;chunk_size&#x60;: the chunk size (in tokens) applied when splitting the document - &#x60;chunk_overlap&#x60;: the chunk overlap (in tokens) applied when splitting the document - &#x60;skip_embedding_generation&#x60;: whether or not to skip the generation of chunks and embeddings - &#x60;set_page_as_boundary&#x60;: described above - &#x60;embedding_model&#x60;: the model used to generate embeddings for the document chunks - &#x60;use_ocr&#x60;: whether or not to use OCR as a preprocessing step prior to generating chunks. Valid for PDFs, JPEGs, and PNGs - &#x60;generate_sparse_vectors&#x60;: whether or not to generate sparse vectors for the file. Required for hybrid search. - &#x60;prepend_filename_to_chunks&#x60;: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \SplFileObject $file (required)
     * @param  \Carbon\Model\BodyCreateUploadFileUploadfilePost $body_create_upload_file_uploadfile_post (required)
     * @param  int $chunk_size Chunk size in tiktoken tokens to be used when processing file. (optional)
     * @param  int $chunk_overlap Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     * @param  bool $skip_embedding_generation Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     * @param  bool $set_page_as_boundary Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     * @param  EmbeddingModel $embedding_model Embedding model that will be used to embed file chunks. (optional)
     * @param  bool $use_ocr Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     * @param  bool $generate_sparse_vectors Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     * @param  bool $prepend_filename_to_chunks Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     * @param  int $max_items_per_chunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     * @param  bool $parse_pdf_tables_with_ocr Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     * @param  bool $detect_audio_language Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     * @param  TranscriptionServiceNullable $transcription_service The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     * @param  bool $include_speaker_labels Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     * @param  FileContentTypesNullable $media_type The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     * @param  bool $split_rows Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     * @param  bool $enable_cold_storage Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     * @param  int $hot_storage_time_to_live Time in seconds after which the file will be moved to cold storage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['upload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAsync(

        $file,
        $chunk_size = SENTINEL_VALUE,
        $chunk_overlap = SENTINEL_VALUE,
        $skip_embedding_generation = false,
        $set_page_as_boundary = false,
        $embedding_model = SENTINEL_VALUE,
        $use_ocr = false,
        $generate_sparse_vectors = false,
        $prepend_filename_to_chunks = false,
        $max_items_per_chunk = SENTINEL_VALUE,
        $parse_pdf_tables_with_ocr = false,
        $detect_audio_language = false,
        $transcription_service = SENTINEL_VALUE,
        $include_speaker_labels = false,
        $media_type = SENTINEL_VALUE,
        $split_rows = false,
        $enable_cold_storage = false,
        $hot_storage_time_to_live = SENTINEL_VALUE,
        string $contentType = self::contentTypes['upload'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "file", $file);
        $body_create_upload_file_uploadfile_post = $_body;

        return $this->uploadAsyncWithHttpInfo($file, $body_create_upload_file_uploadfile_post, $chunk_size, $chunk_overlap, $skip_embedding_generation, $set_page_as_boundary, $embedding_model, $use_ocr, $generate_sparse_vectors, $prepend_filename_to_chunks, $max_items_per_chunk, $parse_pdf_tables_with_ocr, $detect_audio_language, $transcription_service, $include_speaker_labels, $media_type, $split_rows, $enable_cold_storage, $hot_storage_time_to_live, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadAsyncWithHttpInfo
     *
     * Create Upload File
     *
     * This endpoint is used to directly upload local files to Carbon. The &#x60;POST&#x60; request should be a multipart form request. Note that the &#x60;set_page_as_boundary&#x60; query parameter is applicable only to PDFs for now. When this value is set, PDF chunks are at most one page long. Additional information can be retrieved for each chunk, however, namely the coordinates of the bounding box around the chunk (this can be used for things like text highlighting). Following is a description of all possible query parameters: - &#x60;chunk_size&#x60;: the chunk size (in tokens) applied when splitting the document - &#x60;chunk_overlap&#x60;: the chunk overlap (in tokens) applied when splitting the document - &#x60;skip_embedding_generation&#x60;: whether or not to skip the generation of chunks and embeddings - &#x60;set_page_as_boundary&#x60;: described above - &#x60;embedding_model&#x60;: the model used to generate embeddings for the document chunks - &#x60;use_ocr&#x60;: whether or not to use OCR as a preprocessing step prior to generating chunks. Valid for PDFs, JPEGs, and PNGs - &#x60;generate_sparse_vectors&#x60;: whether or not to generate sparse vectors for the file. Required for hybrid search. - &#x60;prepend_filename_to_chunks&#x60;: whether or not to prepend the filename to the chunk text   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \SplFileObject $file (required)
     * @param  \Carbon\Model\BodyCreateUploadFileUploadfilePost $body_create_upload_file_uploadfile_post (required)
     * @param  int $chunk_size Chunk size in tiktoken tokens to be used when processing file. (optional)
     * @param  int $chunk_overlap Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     * @param  bool $skip_embedding_generation Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     * @param  bool $set_page_as_boundary Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     * @param  EmbeddingModel $embedding_model Embedding model that will be used to embed file chunks. (optional)
     * @param  bool $use_ocr Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     * @param  bool $generate_sparse_vectors Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     * @param  bool $prepend_filename_to_chunks Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     * @param  int $max_items_per_chunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     * @param  bool $parse_pdf_tables_with_ocr Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     * @param  bool $detect_audio_language Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     * @param  TranscriptionServiceNullable $transcription_service The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     * @param  bool $include_speaker_labels Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     * @param  FileContentTypesNullable $media_type The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     * @param  bool $split_rows Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     * @param  bool $enable_cold_storage Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     * @param  int $hot_storage_time_to_live Time in seconds after which the file will be moved to cold storage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['upload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadAsyncWithHttpInfo($file, $body_create_upload_file_uploadfile_post, $chunk_size = null, $chunk_overlap = null, $skip_embedding_generation = false, $set_page_as_boundary = false, $embedding_model = null, $use_ocr = false, $generate_sparse_vectors = false, $prepend_filename_to_chunks = false, $max_items_per_chunk = null, $parse_pdf_tables_with_ocr = false, $detect_audio_language = false, $transcription_service = null, $include_speaker_labels = false, $media_type = null, $split_rows = false, $enable_cold_storage = false, $hot_storage_time_to_live = null, string $contentType = self::contentTypes['upload'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\UserFile';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->uploadRequest($file, $body_create_upload_file_uploadfile_post, $chunk_size, $chunk_overlap, $skip_embedding_generation, $set_page_as_boundary, $embedding_model, $use_ocr, $generate_sparse_vectors, $prepend_filename_to_chunks, $max_items_per_chunk, $parse_pdf_tables_with_ocr, $detect_audio_language, $transcription_service, $include_speaker_labels, $media_type, $split_rows, $enable_cold_storage, $hot_storage_time_to_live, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'upload'
     *
     * @param  \SplFileObject $file (required)
     * @param  \Carbon\Model\BodyCreateUploadFileUploadfilePost $body_create_upload_file_uploadfile_post (required)
     * @param  int $chunk_size Chunk size in tiktoken tokens to be used when processing file. (optional)
     * @param  int $chunk_overlap Chunk overlap in tiktoken tokens to be used when processing file. (optional)
     * @param  bool $skip_embedding_generation Flag to control whether or not embeddings should be generated and stored             when processing file. (optional, default to false)
     * @param  bool $set_page_as_boundary Flag to control whether or not to set the a page&#39;s worth of content as the maximum             amount of content that can appear in a chunk. Only valid for PDFs. See description route description for             more information. (optional, default to false)
     * @param  EmbeddingModel $embedding_model Embedding model that will be used to embed file chunks. (optional)
     * @param  bool $use_ocr Whether or not to use OCR when processing files. Valid for PDFs, JPEGs, and PNGs. Useful for documents with             tables, images, and/or scanned text. (optional, default to false)
     * @param  bool $generate_sparse_vectors Whether or not to generate sparse vectors for the file. This is *required* for the file to be a             candidate for hybrid search. (optional, default to false)
     * @param  bool $prepend_filename_to_chunks Whether or not to prepend the file&#39;s name to chunks. (optional, default to false)
     * @param  int $max_items_per_chunk Number of objects per chunk. For csv, tsv, xlsx, and json files only. (optional)
     * @param  bool $parse_pdf_tables_with_ocr Whether to use rich table parsing when &#x60;use_ocr&#x60; is enabled. (optional, default to false)
     * @param  bool $detect_audio_language Whether to automatically detect the language of the uploaded audio file. (optional, default to false)
     * @param  TranscriptionServiceNullable $transcription_service The transcription service to use for audio files. If no service is specified, &#39;deepgram&#39; will be used. (optional)
     * @param  bool $include_speaker_labels Detect multiple speakers and label segments of speech by speaker for audio files. (optional, default to false)
     * @param  FileContentTypesNullable $media_type The media type of the file. If not provided, it will be inferred from the file extension. (optional)
     * @param  bool $split_rows Whether to split tabular rows into chunks. Currently only valid for CSV, TSV, and XLSX files. (optional, default to false)
     * @param  bool $enable_cold_storage Enable cold storage for the file. If set to true, the file will be moved to cold storage after a certain period of inactivity. Default is false. (optional, default to false)
     * @param  int $hot_storage_time_to_live Time in seconds after which the file will be moved to cold storage. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['upload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadRequest($file, $body_create_upload_file_uploadfile_post, $chunk_size = SENTINEL_VALUE, $chunk_overlap = SENTINEL_VALUE, $skip_embedding_generation = false, $set_page_as_boundary = false, $embedding_model = SENTINEL_VALUE, $use_ocr = false, $generate_sparse_vectors = false, $prepend_filename_to_chunks = false, $max_items_per_chunk = SENTINEL_VALUE, $parse_pdf_tables_with_ocr = false, $detect_audio_language = false, $transcription_service = SENTINEL_VALUE, $include_speaker_labels = false, $media_type = SENTINEL_VALUE, $split_rows = false, $enable_cold_storage = false, $hot_storage_time_to_live = SENTINEL_VALUE, string $contentType = self::contentTypes['upload'][0])
    {

        // verify the required parameter 'file' is set
        if ($file === SENTINEL_VALUE || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter file when calling upload'
            );
        }
        if ($body_create_upload_file_uploadfile_post !== SENTINEL_VALUE) {
            if (!($body_create_upload_file_uploadfile_post instanceof \Carbon\Model\BodyCreateUploadFileUploadfilePost)) {
                if (!is_array($body_create_upload_file_uploadfile_post))
                    throw new \InvalidArgumentException('"body_create_upload_file_uploadfile_post" must be associative array or an instance of \Carbon\Model\BodyCreateUploadFileUploadfilePost FilesApi.upload.');
                else
                    $body_create_upload_file_uploadfile_post = new \Carbon\Model\BodyCreateUploadFileUploadfilePost($body_create_upload_file_uploadfile_post);
            }
        }
        // verify the required parameter 'body_create_upload_file_uploadfile_post' is set
        if ($body_create_upload_file_uploadfile_post === SENTINEL_VALUE || (is_array($body_create_upload_file_uploadfile_post) && count($body_create_upload_file_uploadfile_post) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter body_create_upload_file_uploadfile_post when calling upload'
            );
        }
        if ($embedding_model !== SENTINEL_VALUE) {
            if (!($embedding_model instanceof EmbeddingModel)) {
                if (!is_array($embedding_model))
                    throw new \InvalidArgumentException('"embedding_model" must be associative array or an instance of EmbeddingModel FilesApi.upload.');
                else
                    $embedding_model = new EmbeddingModel($embedding_model);
            }
        }


        $resourcePath = '/uploadfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($chunk_size !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $chunk_size,
                'chunk_size', // param base name
                'integer', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($chunk_overlap !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $chunk_overlap,
                'chunk_overlap', // param base name
                'integer', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($skip_embedding_generation !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $skip_embedding_generation,
                'skip_embedding_generation', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($set_page_as_boundary !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $set_page_as_boundary,
                'set_page_as_boundary', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($embedding_model !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $embedding_model,
                'embedding_model', // param base name
                'AnyOfTextEmbeddingGeneratorsString', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($use_ocr !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $use_ocr,
                'use_ocr', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($generate_sparse_vectors !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $generate_sparse_vectors,
                'generate_sparse_vectors', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($prepend_filename_to_chunks !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $prepend_filename_to_chunks,
                'prepend_filename_to_chunks', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($max_items_per_chunk !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $max_items_per_chunk,
                'max_items_per_chunk', // param base name
                'integer', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($parse_pdf_tables_with_ocr !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $parse_pdf_tables_with_ocr,
                'parse_pdf_tables_with_ocr', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($detect_audio_language !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $detect_audio_language,
                'detect_audio_language', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($transcription_service !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $transcription_service,
                'transcription_service', // param base name
                'TranscriptionServiceNullable', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($include_speaker_labels !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $include_speaker_labels,
                'include_speaker_labels', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($media_type !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $media_type,
                'media_type', // param base name
                'FileContentTypesNullable', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($split_rows !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $split_rows,
                'split_rows', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($enable_cold_storage !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $enable_cold_storage,
                'enable_cold_storage', // param base name
                'boolean', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }
        if ($hot_storage_time_to_live !== SENTINEL_VALUE) {
            // query params
            $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
                $hot_storage_time_to_live,
                'hot_storage_time_to_live', // param base name
                'integer', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? []);
        }



        // form params
        if ($file !== SENTINEL_VALUE) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body_create_upload_file_uploadfile_post)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($body_create_upload_file_uploadfile_post));
            } else {
                $httpBody = $body_create_upload_file_uploadfile_post;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation uploadFromUrl
     *
     * Create Upload File From Url
     *
     * @param  \Carbon\Model\UploadFileFromUrlInput $upload_file_from_url_input upload_file_from_url_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFromUrl'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError
     */
    public function uploadFromUrl(

        $url,
        $file_name = SENTINEL_VALUE,
        $chunk_size = SENTINEL_VALUE,
        $chunk_overlap = SENTINEL_VALUE,
        $skip_embedding_generation = false,
        $set_page_as_boundary = false,
        $embedding_model = SENTINEL_VALUE,
        $generate_sparse_vectors = false,
        $use_textract = false,
        $prepend_filename_to_chunks = false,
        $max_items_per_chunk = SENTINEL_VALUE,
        $parse_pdf_tables_with_ocr = false,
        $detect_audio_language = false,
        $transcription_service = SENTINEL_VALUE,
        $include_speaker_labels = false,
        $media_type = SENTINEL_VALUE,
        $split_rows = false,
        $cold_storage_params = SENTINEL_VALUE,
        string $contentType = self::contentTypes['uploadFromUrl'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "url", $url);
        $this->setRequestBodyProperty($_body, "file_name", $file_name);
        $this->setRequestBodyProperty($_body, "chunk_size", $chunk_size);
        $this->setRequestBodyProperty($_body, "chunk_overlap", $chunk_overlap);
        $this->setRequestBodyProperty($_body, "skip_embedding_generation", $skip_embedding_generation);
        $this->setRequestBodyProperty($_body, "set_page_as_boundary", $set_page_as_boundary);
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "generate_sparse_vectors", $generate_sparse_vectors);
        $this->setRequestBodyProperty($_body, "use_textract", $use_textract);
        $this->setRequestBodyProperty($_body, "prepend_filename_to_chunks", $prepend_filename_to_chunks);
        $this->setRequestBodyProperty($_body, "max_items_per_chunk", $max_items_per_chunk);
        $this->setRequestBodyProperty($_body, "parse_pdf_tables_with_ocr", $parse_pdf_tables_with_ocr);
        $this->setRequestBodyProperty($_body, "detect_audio_language", $detect_audio_language);
        $this->setRequestBodyProperty($_body, "transcription_service", $transcription_service);
        $this->setRequestBodyProperty($_body, "include_speaker_labels", $include_speaker_labels);
        $this->setRequestBodyProperty($_body, "media_type", $media_type);
        $this->setRequestBodyProperty($_body, "split_rows", $split_rows);
        $this->setRequestBodyProperty($_body, "cold_storage_params", $cold_storage_params);
        $upload_file_from_url_input = $_body;

        list($response) = $this->uploadFromUrlWithHttpInfo($upload_file_from_url_input, $contentType);
        return $response;
    }

    /**
     * Operation uploadFromUrlWithHttpInfo
     *
     * Create Upload File From Url
     *
     * @param  \Carbon\Model\UploadFileFromUrlInput $upload_file_from_url_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFromUrl'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadFromUrlWithHttpInfo($upload_file_from_url_input, string $contentType = self::contentTypes['uploadFromUrl'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->uploadFromUrlRequest($upload_file_from_url_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->uploadFromUrlWithHttpInfo(
                        $upload_file_from_url_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\UserFile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\UserFile' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\UserFile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\UserFile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\UserFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadFromUrlAsync
     *
     * Create Upload File From Url
     *
     * @param  \Carbon\Model\UploadFileFromUrlInput $upload_file_from_url_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFromUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFromUrlAsync(

        $url,
        $file_name = SENTINEL_VALUE,
        $chunk_size = SENTINEL_VALUE,
        $chunk_overlap = SENTINEL_VALUE,
        $skip_embedding_generation = false,
        $set_page_as_boundary = false,
        $embedding_model = SENTINEL_VALUE,
        $generate_sparse_vectors = false,
        $use_textract = false,
        $prepend_filename_to_chunks = false,
        $max_items_per_chunk = SENTINEL_VALUE,
        $parse_pdf_tables_with_ocr = false,
        $detect_audio_language = false,
        $transcription_service = SENTINEL_VALUE,
        $include_speaker_labels = false,
        $media_type = SENTINEL_VALUE,
        $split_rows = false,
        $cold_storage_params = SENTINEL_VALUE,
        string $contentType = self::contentTypes['uploadFromUrl'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "url", $url);
        $this->setRequestBodyProperty($_body, "file_name", $file_name);
        $this->setRequestBodyProperty($_body, "chunk_size", $chunk_size);
        $this->setRequestBodyProperty($_body, "chunk_overlap", $chunk_overlap);
        $this->setRequestBodyProperty($_body, "skip_embedding_generation", $skip_embedding_generation);
        $this->setRequestBodyProperty($_body, "set_page_as_boundary", $set_page_as_boundary);
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "generate_sparse_vectors", $generate_sparse_vectors);
        $this->setRequestBodyProperty($_body, "use_textract", $use_textract);
        $this->setRequestBodyProperty($_body, "prepend_filename_to_chunks", $prepend_filename_to_chunks);
        $this->setRequestBodyProperty($_body, "max_items_per_chunk", $max_items_per_chunk);
        $this->setRequestBodyProperty($_body, "parse_pdf_tables_with_ocr", $parse_pdf_tables_with_ocr);
        $this->setRequestBodyProperty($_body, "detect_audio_language", $detect_audio_language);
        $this->setRequestBodyProperty($_body, "transcription_service", $transcription_service);
        $this->setRequestBodyProperty($_body, "include_speaker_labels", $include_speaker_labels);
        $this->setRequestBodyProperty($_body, "media_type", $media_type);
        $this->setRequestBodyProperty($_body, "split_rows", $split_rows);
        $this->setRequestBodyProperty($_body, "cold_storage_params", $cold_storage_params);
        $upload_file_from_url_input = $_body;

        return $this->uploadFromUrlAsyncWithHttpInfo($upload_file_from_url_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFromUrlAsyncWithHttpInfo
     *
     * Create Upload File From Url
     *
     * @param  \Carbon\Model\UploadFileFromUrlInput $upload_file_from_url_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFromUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFromUrlAsyncWithHttpInfo($upload_file_from_url_input, string $contentType = self::contentTypes['uploadFromUrl'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\UserFile';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->uploadFromUrlRequest($upload_file_from_url_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadFromUrl'
     *
     * @param  \Carbon\Model\UploadFileFromUrlInput $upload_file_from_url_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFromUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadFromUrlRequest($upload_file_from_url_input, string $contentType = self::contentTypes['uploadFromUrl'][0])
    {

        if ($upload_file_from_url_input !== SENTINEL_VALUE) {
            if (!($upload_file_from_url_input instanceof \Carbon\Model\UploadFileFromUrlInput)) {
                if (!is_array($upload_file_from_url_input))
                    throw new \InvalidArgumentException('"upload_file_from_url_input" must be associative array or an instance of \Carbon\Model\UploadFileFromUrlInput FilesApi.uploadFromUrl.');
                else
                    $upload_file_from_url_input = new \Carbon\Model\UploadFileFromUrlInput($upload_file_from_url_input);
            }
        }
        // verify the required parameter 'upload_file_from_url_input' is set
        if ($upload_file_from_url_input === SENTINEL_VALUE || (is_array($upload_file_from_url_input) && count($upload_file_from_url_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter upload_file_from_url_input when calling uploadFromUrl'
            );
        }


        $resourcePath = '/upload_file_from_url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($upload_file_from_url_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($upload_file_from_url_input));
            } else {
                $httpBody = $upload_file_from_url_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation uploadText
     *
     * Create Raw Text
     *
     * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \Carbon\Model\RawTextInput $raw_text_input raw_text_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadText'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError
     */
    public function uploadText(

        $contents,
        $name = SENTINEL_VALUE,
        $chunk_size = SENTINEL_VALUE,
        $chunk_overlap = SENTINEL_VALUE,
        $skip_embedding_generation = false,
        $overwrite_file_id = SENTINEL_VALUE,
        $embedding_model = SENTINEL_VALUE,
        $generate_sparse_vectors = false,
        $cold_storage_params = SENTINEL_VALUE,
        string $contentType = self::contentTypes['uploadText'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "contents", $contents);
        $this->setRequestBodyProperty($_body, "name", $name);
        $this->setRequestBodyProperty($_body, "chunk_size", $chunk_size);
        $this->setRequestBodyProperty($_body, "chunk_overlap", $chunk_overlap);
        $this->setRequestBodyProperty($_body, "skip_embedding_generation", $skip_embedding_generation);
        $this->setRequestBodyProperty($_body, "overwrite_file_id", $overwrite_file_id);
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "generate_sparse_vectors", $generate_sparse_vectors);
        $this->setRequestBodyProperty($_body, "cold_storage_params", $cold_storage_params);
        $raw_text_input = $_body;

        list($response) = $this->uploadTextWithHttpInfo($raw_text_input, $contentType);
        return $response;
    }

    /**
     * Operation uploadTextWithHttpInfo
     *
     * Create Raw Text
     *
     * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \Carbon\Model\RawTextInput $raw_text_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadText'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\UserFile|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadTextWithHttpInfo($raw_text_input, string $contentType = self::contentTypes['uploadText'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->uploadTextRequest($raw_text_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->uploadTextWithHttpInfo(
                        $raw_text_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\UserFile' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\UserFile' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\UserFile', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\UserFile';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\UserFile',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadTextAsync
     *
     * Create Raw Text
     *
     * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \Carbon\Model\RawTextInput $raw_text_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadTextAsync(

        $contents,
        $name = SENTINEL_VALUE,
        $chunk_size = SENTINEL_VALUE,
        $chunk_overlap = SENTINEL_VALUE,
        $skip_embedding_generation = false,
        $overwrite_file_id = SENTINEL_VALUE,
        $embedding_model = SENTINEL_VALUE,
        $generate_sparse_vectors = false,
        $cold_storage_params = SENTINEL_VALUE,
        string $contentType = self::contentTypes['uploadText'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "contents", $contents);
        $this->setRequestBodyProperty($_body, "name", $name);
        $this->setRequestBodyProperty($_body, "chunk_size", $chunk_size);
        $this->setRequestBodyProperty($_body, "chunk_overlap", $chunk_overlap);
        $this->setRequestBodyProperty($_body, "skip_embedding_generation", $skip_embedding_generation);
        $this->setRequestBodyProperty($_body, "overwrite_file_id", $overwrite_file_id);
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "generate_sparse_vectors", $generate_sparse_vectors);
        $this->setRequestBodyProperty($_body, "cold_storage_params", $cold_storage_params);
        $raw_text_input = $_body;

        return $this->uploadTextAsyncWithHttpInfo($raw_text_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadTextAsyncWithHttpInfo
     *
     * Create Raw Text
     *
     * Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \Carbon\Model\RawTextInput $raw_text_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadTextAsyncWithHttpInfo($raw_text_input, string $contentType = self::contentTypes['uploadText'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\UserFile';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->uploadTextRequest($raw_text_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadText'
     *
     * @param  \Carbon\Model\RawTextInput $raw_text_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadText'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadTextRequest($raw_text_input, string $contentType = self::contentTypes['uploadText'][0])
    {

        if ($raw_text_input !== SENTINEL_VALUE) {
            if (!($raw_text_input instanceof \Carbon\Model\RawTextInput)) {
                if (!is_array($raw_text_input))
                    throw new \InvalidArgumentException('"raw_text_input" must be associative array or an instance of \Carbon\Model\RawTextInput FilesApi.uploadText.');
                else
                    $raw_text_input = new \Carbon\Model\RawTextInput($raw_text_input);
            }
        }
        // verify the required parameter 'raw_text_input' is set
        if ($raw_text_input === SENTINEL_VALUE || (is_array($raw_text_input) && count($raw_text_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter raw_text_input when calling uploadText'
            );
        }


        $resourcePath = '/upload_text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($raw_text_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($raw_text_input));
            } else {
                $httpBody = $raw_text_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
