<?php
/**
 * EmbeddingsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Carbon
 * @author   Konfig
 * @link     https://konfigthis.com
 */

/**
 * Carbon
 *
 * Connect external data to LLMs, no matter the source.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://konfigthis.com
 */


namespace Carbon\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\BodySummarizer;
use GuzzleHttp\Middleware;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Utils;
use Carbon\ApiException;
use Carbon\Configuration;
use Carbon\HeaderSelector;
use Carbon\ObjectSerializer;

class EmbeddingsApi extends \Carbon\CustomApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'all' => [
            'application/json',
        ],
        'getDocuments' => [
            'application/json',
        ],
        'getEmbeddingsAndChunks' => [
            'application/json',
        ],
        'uploadChunksAndEmbeddings' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $clientOptions = [];
        if (!$config->getVerifySsl()) $clientOptions["verify"] = false;

        // Do not truncate error messages
        // https://github.com/guzzle/guzzle/issues/2185#issuecomment-800293420
        $stack = new HandlerStack(Utils::chooseHandler());
        $stack->push(Middleware::httpErrors(new BodySummarizer(10000)), 'http_errors');
        $stack->push(Middleware::redirect(), 'allow_redirects');
        $stack->push(Middleware::cookies(), 'cookies');
        $stack->push(Middleware::prepareBody(), 'prepare_body');
        $clientOptions["handler"] = $stack;

        $this->client = $client ?: new Client($clientOptions);
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * For initializing request body parameter
     */
    private function setRequestBodyProperty(&$body, $property, $value) {
        if ($body === null) $body = [];
        // user did not pass in a value for this parameter
        if ($value === SENTINEL_VALUE) return;
        $body[$property] = $value;
    }

    /**
     * Operation all
     *
     * Retrieve Embeddings And Content V2
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInputV2 $embeddings_and_chunks_query_input_v2 embeddings_and_chunks_query_input_v2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\EmbeddingsAndChunksResponse|\Carbon\Model\HTTPValidationError
     */
    public function all(

        $filters,
        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        $include_vectors = false,
        string $contentType = self::contentTypes['all'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "include_vectors", $include_vectors);
        $embeddings_and_chunks_query_input_v2 = $_body;

        list($response) = $this->allWithHttpInfo($embeddings_and_chunks_query_input_v2, $contentType);
        return $response;
    }

    /**
     * Operation allWithHttpInfo
     *
     * Retrieve Embeddings And Content V2
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInputV2 $embeddings_and_chunks_query_input_v2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\EmbeddingsAndChunksResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function allWithHttpInfo($embeddings_and_chunks_query_input_v2, string $contentType = self::contentTypes['all'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->allRequest($embeddings_and_chunks_query_input_v2, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->allWithHttpInfo(
                        $embeddings_and_chunks_query_input_v2,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\EmbeddingsAndChunksResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\EmbeddingsAndChunksResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\EmbeddingsAndChunksResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\EmbeddingsAndChunksResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\EmbeddingsAndChunksResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation allAsync
     *
     * Retrieve Embeddings And Content V2
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInputV2 $embeddings_and_chunks_query_input_v2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allAsync(

        $filters,
        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        $include_vectors = false,
        string $contentType = self::contentTypes['all'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "include_vectors", $include_vectors);
        $embeddings_and_chunks_query_input_v2 = $_body;

        return $this->allAsyncWithHttpInfo($embeddings_and_chunks_query_input_v2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation allAsyncWithHttpInfo
     *
     * Retrieve Embeddings And Content V2
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInputV2 $embeddings_and_chunks_query_input_v2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allAsyncWithHttpInfo($embeddings_and_chunks_query_input_v2, string $contentType = self::contentTypes['all'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\EmbeddingsAndChunksResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->allRequest($embeddings_and_chunks_query_input_v2, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'all'
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInputV2 $embeddings_and_chunks_query_input_v2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['all'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function allRequest($embeddings_and_chunks_query_input_v2, string $contentType = self::contentTypes['all'][0])
    {

        if ($embeddings_and_chunks_query_input_v2 !== SENTINEL_VALUE) {
            if (!($embeddings_and_chunks_query_input_v2 instanceof \Carbon\Model\EmbeddingsAndChunksQueryInputV2)) {
                if (!is_array($embeddings_and_chunks_query_input_v2))
                    throw new \InvalidArgumentException('"embeddings_and_chunks_query_input_v2" must be associative array or an instance of \Carbon\Model\EmbeddingsAndChunksQueryInputV2 EmbeddingsApi.all.');
                else
                    $embeddings_and_chunks_query_input_v2 = new \Carbon\Model\EmbeddingsAndChunksQueryInputV2($embeddings_and_chunks_query_input_v2);
            }
        }
        // verify the required parameter 'embeddings_and_chunks_query_input_v2' is set
        if ($embeddings_and_chunks_query_input_v2 === SENTINEL_VALUE || (is_array($embeddings_and_chunks_query_input_v2) && count($embeddings_and_chunks_query_input_v2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter embeddings_and_chunks_query_input_v2 when calling all'
            );
        }


        $resourcePath = '/list_chunks_and_embeddings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($embeddings_and_chunks_query_input_v2)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($embeddings_and_chunks_query_input_v2));
            } else {
                $httpBody = $embeddings_and_chunks_query_input_v2;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getDocuments
     *
     * Embeddings
     *
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.   When querying embeddings, you can optionally specify the &#x60;media_type&#x60; parameter in your request. By default (if not set), it is equal to \&quot;TEXT\&quot;. This means that the query will be performed over files that have been parsed as text (for now, this covers all files except image files). If it is equal to \&quot;IMAGE\&quot;, the query will be performed over image files (for now, &#x60;.jpg&#x60; and &#x60;.png&#x60; files). You can think of this field as an additional filter on top of any filters set in &#x60;file_ids&#x60; and   When &#x60;hybrid_search&#x60; is set to true, a combination of keyword search and semantic search are used to rank and select candidate embeddings during information retrieval. By default, these search methods are weighted equally during the ranking process. To adjust the weight (or \&quot;importance\&quot;) of each search method, you can use the &#x60;hybrid_search_tuning_parameters&#x60; property. The description for the different tuning parameters are: - &#x60;weight_a&#x60;: weight to assign to semantic search - &#x60;weight_b&#x60;: weight to assign to keyword search  You must ensure that &#x60;sum(weight_a, weight_b,..., weight_n)&#x60; for all *n* weights is equal to 1. The equality has an error tolerance of 0.001 to account for possible floating point issues.  In order to use hybrid search for a customer across a set of documents, two flags need to be enabled: 1. Use the &#x60;/modify_user_configuration&#x60; endpoint to to enable &#x60;sparse_vectors&#x60; for the customer. The payload body for this request is below: &#x60;&#x60;&#x60; {   \&quot;configuration_key_name\&quot;: \&quot;sparse_vectors\&quot;,   \&quot;value\&quot;: {     \&quot;enabled\&quot;: true   } } &#x60;&#x60;&#x60; 2. Make sure hybrid search is enabled for the documents across which you want to perform the search. For the &#x60;/uploadfile&#x60; endpoint, this can be done by setting the following query parameter: &#x60;generate_sparse_vectors&#x3D;true&#x60;   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \Carbon\Model\GetEmbeddingDocumentsBody $get_embedding_documents_body get_embedding_documents_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\DocumentResponseList|\Carbon\Model\HTTPValidationError
     */
    public function getDocuments(

        $query,
        $k,
        $tags = SENTINEL_VALUE,
        $query_vector = SENTINEL_VALUE,
        $file_ids = SENTINEL_VALUE,
        $parent_file_ids = SENTINEL_VALUE,
        $include_all_children = false,
        $tags_v2 = SENTINEL_VALUE,
        $include_tags = SENTINEL_VALUE,
        $include_vectors = SENTINEL_VALUE,
        $include_raw_file = SENTINEL_VALUE,
        $hybrid_search = SENTINEL_VALUE,
        $hybrid_search_tuning_parameters = SENTINEL_VALUE,
        $media_type = SENTINEL_VALUE,
        $embedding_model = SENTINEL_VALUE,
        $include_file_level_metadata = false,
        $high_accuracy = false,
        $rerank = SENTINEL_VALUE,
        $file_types_at_source = SENTINEL_VALUE,
        $exclude_cold_storage_files = false,
        string $contentType = self::contentTypes['getDocuments'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "tags", $tags);
        $this->setRequestBodyProperty($_body, "query", $query);
        $this->setRequestBodyProperty($_body, "query_vector", $query_vector);
        $this->setRequestBodyProperty($_body, "k", $k);
        $this->setRequestBodyProperty($_body, "file_ids", $file_ids);
        $this->setRequestBodyProperty($_body, "parent_file_ids", $parent_file_ids);
        $this->setRequestBodyProperty($_body, "include_all_children", $include_all_children);
        $this->setRequestBodyProperty($_body, "tags_v2", $tags_v2);
        $this->setRequestBodyProperty($_body, "include_tags", $include_tags);
        $this->setRequestBodyProperty($_body, "include_vectors", $include_vectors);
        $this->setRequestBodyProperty($_body, "include_raw_file", $include_raw_file);
        $this->setRequestBodyProperty($_body, "hybrid_search", $hybrid_search);
        $this->setRequestBodyProperty($_body, "hybrid_search_tuning_parameters", $hybrid_search_tuning_parameters);
        $this->setRequestBodyProperty($_body, "media_type", $media_type);
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "include_file_level_metadata", $include_file_level_metadata);
        $this->setRequestBodyProperty($_body, "high_accuracy", $high_accuracy);
        $this->setRequestBodyProperty($_body, "rerank", $rerank);
        $this->setRequestBodyProperty($_body, "file_types_at_source", $file_types_at_source);
        $this->setRequestBodyProperty($_body, "exclude_cold_storage_files", $exclude_cold_storage_files);
        $get_embedding_documents_body = $_body;

        list($response) = $this->getDocumentsWithHttpInfo($get_embedding_documents_body, $contentType);
        return $response;
    }

    /**
     * Operation getDocumentsWithHttpInfo
     *
     * Embeddings
     *
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.   When querying embeddings, you can optionally specify the &#x60;media_type&#x60; parameter in your request. By default (if not set), it is equal to \&quot;TEXT\&quot;. This means that the query will be performed over files that have been parsed as text (for now, this covers all files except image files). If it is equal to \&quot;IMAGE\&quot;, the query will be performed over image files (for now, &#x60;.jpg&#x60; and &#x60;.png&#x60; files). You can think of this field as an additional filter on top of any filters set in &#x60;file_ids&#x60; and   When &#x60;hybrid_search&#x60; is set to true, a combination of keyword search and semantic search are used to rank and select candidate embeddings during information retrieval. By default, these search methods are weighted equally during the ranking process. To adjust the weight (or \&quot;importance\&quot;) of each search method, you can use the &#x60;hybrid_search_tuning_parameters&#x60; property. The description for the different tuning parameters are: - &#x60;weight_a&#x60;: weight to assign to semantic search - &#x60;weight_b&#x60;: weight to assign to keyword search  You must ensure that &#x60;sum(weight_a, weight_b,..., weight_n)&#x60; for all *n* weights is equal to 1. The equality has an error tolerance of 0.001 to account for possible floating point issues.  In order to use hybrid search for a customer across a set of documents, two flags need to be enabled: 1. Use the &#x60;/modify_user_configuration&#x60; endpoint to to enable &#x60;sparse_vectors&#x60; for the customer. The payload body for this request is below: &#x60;&#x60;&#x60; {   \&quot;configuration_key_name\&quot;: \&quot;sparse_vectors\&quot;,   \&quot;value\&quot;: {     \&quot;enabled\&quot;: true   } } &#x60;&#x60;&#x60; 2. Make sure hybrid search is enabled for the documents across which you want to perform the search. For the &#x60;/uploadfile&#x60; endpoint, this can be done by setting the following query parameter: &#x60;generate_sparse_vectors&#x3D;true&#x60;   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \Carbon\Model\GetEmbeddingDocumentsBody $get_embedding_documents_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\DocumentResponseList|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocumentsWithHttpInfo($get_embedding_documents_body, string $contentType = self::contentTypes['getDocuments'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getDocumentsRequest($get_embedding_documents_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getDocumentsWithHttpInfo(
                        $get_embedding_documents_body,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\DocumentResponseList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\DocumentResponseList' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\DocumentResponseList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\DocumentResponseList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\DocumentResponseList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDocumentsAsync
     *
     * Embeddings
     *
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.   When querying embeddings, you can optionally specify the &#x60;media_type&#x60; parameter in your request. By default (if not set), it is equal to \&quot;TEXT\&quot;. This means that the query will be performed over files that have been parsed as text (for now, this covers all files except image files). If it is equal to \&quot;IMAGE\&quot;, the query will be performed over image files (for now, &#x60;.jpg&#x60; and &#x60;.png&#x60; files). You can think of this field as an additional filter on top of any filters set in &#x60;file_ids&#x60; and   When &#x60;hybrid_search&#x60; is set to true, a combination of keyword search and semantic search are used to rank and select candidate embeddings during information retrieval. By default, these search methods are weighted equally during the ranking process. To adjust the weight (or \&quot;importance\&quot;) of each search method, you can use the &#x60;hybrid_search_tuning_parameters&#x60; property. The description for the different tuning parameters are: - &#x60;weight_a&#x60;: weight to assign to semantic search - &#x60;weight_b&#x60;: weight to assign to keyword search  You must ensure that &#x60;sum(weight_a, weight_b,..., weight_n)&#x60; for all *n* weights is equal to 1. The equality has an error tolerance of 0.001 to account for possible floating point issues.  In order to use hybrid search for a customer across a set of documents, two flags need to be enabled: 1. Use the &#x60;/modify_user_configuration&#x60; endpoint to to enable &#x60;sparse_vectors&#x60; for the customer. The payload body for this request is below: &#x60;&#x60;&#x60; {   \&quot;configuration_key_name\&quot;: \&quot;sparse_vectors\&quot;,   \&quot;value\&quot;: {     \&quot;enabled\&quot;: true   } } &#x60;&#x60;&#x60; 2. Make sure hybrid search is enabled for the documents across which you want to perform the search. For the &#x60;/uploadfile&#x60; endpoint, this can be done by setting the following query parameter: &#x60;generate_sparse_vectors&#x3D;true&#x60;   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \Carbon\Model\GetEmbeddingDocumentsBody $get_embedding_documents_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentsAsync(

        $query,
        $k,
        $tags = SENTINEL_VALUE,
        $query_vector = SENTINEL_VALUE,
        $file_ids = SENTINEL_VALUE,
        $parent_file_ids = SENTINEL_VALUE,
        $include_all_children = false,
        $tags_v2 = SENTINEL_VALUE,
        $include_tags = SENTINEL_VALUE,
        $include_vectors = SENTINEL_VALUE,
        $include_raw_file = SENTINEL_VALUE,
        $hybrid_search = SENTINEL_VALUE,
        $hybrid_search_tuning_parameters = SENTINEL_VALUE,
        $media_type = SENTINEL_VALUE,
        $embedding_model = SENTINEL_VALUE,
        $include_file_level_metadata = false,
        $high_accuracy = false,
        $rerank = SENTINEL_VALUE,
        $file_types_at_source = SENTINEL_VALUE,
        $exclude_cold_storage_files = false,
        string $contentType = self::contentTypes['getDocuments'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "tags", $tags);
        $this->setRequestBodyProperty($_body, "query", $query);
        $this->setRequestBodyProperty($_body, "query_vector", $query_vector);
        $this->setRequestBodyProperty($_body, "k", $k);
        $this->setRequestBodyProperty($_body, "file_ids", $file_ids);
        $this->setRequestBodyProperty($_body, "parent_file_ids", $parent_file_ids);
        $this->setRequestBodyProperty($_body, "include_all_children", $include_all_children);
        $this->setRequestBodyProperty($_body, "tags_v2", $tags_v2);
        $this->setRequestBodyProperty($_body, "include_tags", $include_tags);
        $this->setRequestBodyProperty($_body, "include_vectors", $include_vectors);
        $this->setRequestBodyProperty($_body, "include_raw_file", $include_raw_file);
        $this->setRequestBodyProperty($_body, "hybrid_search", $hybrid_search);
        $this->setRequestBodyProperty($_body, "hybrid_search_tuning_parameters", $hybrid_search_tuning_parameters);
        $this->setRequestBodyProperty($_body, "media_type", $media_type);
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "include_file_level_metadata", $include_file_level_metadata);
        $this->setRequestBodyProperty($_body, "high_accuracy", $high_accuracy);
        $this->setRequestBodyProperty($_body, "rerank", $rerank);
        $this->setRequestBodyProperty($_body, "file_types_at_source", $file_types_at_source);
        $this->setRequestBodyProperty($_body, "exclude_cold_storage_files", $exclude_cold_storage_files);
        $get_embedding_documents_body = $_body;

        return $this->getDocumentsAsyncWithHttpInfo($get_embedding_documents_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocumentsAsyncWithHttpInfo
     *
     * Embeddings
     *
     * For pre-filtering documents, using &#x60;tags_v2&#x60; is preferred to using &#x60;tags&#x60; (which is now deprecated). If both &#x60;tags_v2&#x60; and &#x60;tags&#x60; are specified, &#x60;tags&#x60; is ignored. &#x60;tags_v2&#x60; enables building complex filters through the use of \&quot;AND\&quot;, \&quot;OR\&quot;, and negation logic. Take the below input as an example: &#x60;&#x60;&#x60;json {     \&quot;OR\&quot;: [         {             \&quot;key\&quot;: \&quot;subject\&quot;,             \&quot;value\&quot;: \&quot;holy-bible\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;person-of-interest\&quot;,             \&quot;value\&quot;: \&quot;jesus christ\&quot;,             \&quot;negate\&quot;: false         },         {             \&quot;key\&quot;: \&quot;genre\&quot;,             \&quot;value\&quot;: \&quot;religion\&quot;,             \&quot;negate\&quot;: true         }         {             \&quot;AND\&quot;: [                 {                     \&quot;key\&quot;: \&quot;subject\&quot;,                     \&quot;value\&quot;: \&quot;tao-te-ching\&quot;,                     \&quot;negate\&quot;: false                 },                 {                     \&quot;key\&quot;: \&quot;author\&quot;,                     \&quot;value\&quot;: \&quot;lao-tzu\&quot;,                     \&quot;negate\&quot;: false                 }             ]         }     ] } &#x60;&#x60;&#x60; In this case, files will be filtered such that: 1. \&quot;subject\&quot; &#x3D; \&quot;holy-bible\&quot; OR 2. \&quot;person-of-interest\&quot; &#x3D; \&quot;jesus christ\&quot; OR 3. \&quot;genre\&quot; !&#x3D; \&quot;religion\&quot; OR 4. \&quot;subject\&quot; &#x3D; \&quot;tao-te-ching\&quot; AND \&quot;author\&quot; &#x3D; \&quot;lao-tzu\&quot;  Note that the top level of the query must be either an \&quot;OR\&quot; or \&quot;AND\&quot; array. Currently, nesting is limited to 3. For tag blocks (those with \&quot;key\&quot;, \&quot;value\&quot;, and \&quot;negate\&quot; keys), the following typing rules apply: 1. \&quot;key\&quot; isn&#39;t optional and must be a &#x60;string&#x60; 2. \&quot;value\&quot; isn&#39;t optional and can be &#x60;any&#x60; or list[&#x60;any&#x60;] 3. \&quot;negate\&quot; is optional and must be &#x60;true&#x60; or &#x60;false&#x60;. If present and &#x60;true&#x60;, then the filter block is negated in the resulting query. It is &#x60;false&#x60; by default.   When querying embeddings, you can optionally specify the &#x60;media_type&#x60; parameter in your request. By default (if not set), it is equal to \&quot;TEXT\&quot;. This means that the query will be performed over files that have been parsed as text (for now, this covers all files except image files). If it is equal to \&quot;IMAGE\&quot;, the query will be performed over image files (for now, &#x60;.jpg&#x60; and &#x60;.png&#x60; files). You can think of this field as an additional filter on top of any filters set in &#x60;file_ids&#x60; and   When &#x60;hybrid_search&#x60; is set to true, a combination of keyword search and semantic search are used to rank and select candidate embeddings during information retrieval. By default, these search methods are weighted equally during the ranking process. To adjust the weight (or \&quot;importance\&quot;) of each search method, you can use the &#x60;hybrid_search_tuning_parameters&#x60; property. The description for the different tuning parameters are: - &#x60;weight_a&#x60;: weight to assign to semantic search - &#x60;weight_b&#x60;: weight to assign to keyword search  You must ensure that &#x60;sum(weight_a, weight_b,..., weight_n)&#x60; for all *n* weights is equal to 1. The equality has an error tolerance of 0.001 to account for possible floating point issues.  In order to use hybrid search for a customer across a set of documents, two flags need to be enabled: 1. Use the &#x60;/modify_user_configuration&#x60; endpoint to to enable &#x60;sparse_vectors&#x60; for the customer. The payload body for this request is below: &#x60;&#x60;&#x60; {   \&quot;configuration_key_name\&quot;: \&quot;sparse_vectors\&quot;,   \&quot;value\&quot;: {     \&quot;enabled\&quot;: true   } } &#x60;&#x60;&#x60; 2. Make sure hybrid search is enabled for the documents across which you want to perform the search. For the &#x60;/uploadfile&#x60; endpoint, this can be done by setting the following query parameter: &#x60;generate_sparse_vectors&#x3D;true&#x60;   Carbon supports multiple models for use in generating embeddings for files. For images, we support Vertex AI&#39;s multimodal model; for text, we support OpenAI&#39;s &#x60;text-embedding-ada-002&#x60; and Cohere&#39;s embed-multilingual-v3.0. The model can be specified via the &#x60;embedding_model&#x60; parameter (in the POST body for &#x60;/embeddings&#x60;, and a query  parameter in &#x60;/uploadfile&#x60;). If no model is supplied, the &#x60;text-embedding-ada-002&#x60; is used by default. When performing embedding queries, embeddings from files that used the specified model will be considered in the query. For example, if files A and B have embeddings generated with &#x60;OPENAI&#x60;, and files C and D have embeddings generated with &#x60;COHERE_MULTILINGUAL_V3&#x60;, then by default, queries will only consider files A and B. If &#x60;COHERE_MULTILINGUAL_V3&#x60; is specified as the &#x60;embedding_model&#x60; in &#x60;/embeddings&#x60;, then only files C and D will be considered. Make sure that the set of all files you want considered for a query have embeddings generated via the same model. For now, **do not** set &#x60;VERTEX_MULTIMODAL&#x60; as an &#x60;embedding_model&#x60;. This model is used automatically by Carbon when it detects an image file.
     *
     * @param  \Carbon\Model\GetEmbeddingDocumentsBody $get_embedding_documents_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentsAsyncWithHttpInfo($get_embedding_documents_body, string $contentType = self::contentTypes['getDocuments'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\DocumentResponseList';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getDocumentsRequest($get_embedding_documents_body, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocuments'
     *
     * @param  \Carbon\Model\GetEmbeddingDocumentsBody $get_embedding_documents_body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocumentsRequest($get_embedding_documents_body, string $contentType = self::contentTypes['getDocuments'][0])
    {

        if ($get_embedding_documents_body !== SENTINEL_VALUE) {
            if (!($get_embedding_documents_body instanceof \Carbon\Model\GetEmbeddingDocumentsBody)) {
                if (!is_array($get_embedding_documents_body))
                    throw new \InvalidArgumentException('"get_embedding_documents_body" must be associative array or an instance of \Carbon\Model\GetEmbeddingDocumentsBody EmbeddingsApi.getDocuments.');
                else
                    $get_embedding_documents_body = new \Carbon\Model\GetEmbeddingDocumentsBody($get_embedding_documents_body);
            }
        }
        // verify the required parameter 'get_embedding_documents_body' is set
        if ($get_embedding_documents_body === SENTINEL_VALUE || (is_array($get_embedding_documents_body) && count($get_embedding_documents_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter get_embedding_documents_body when calling getDocuments'
            );
        }


        $resourcePath = '/embeddings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($get_embedding_documents_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($get_embedding_documents_body));
            } else {
                $httpBody = $get_embedding_documents_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation getEmbeddingsAndChunks
     *
     * Retrieve Embeddings And Content
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInput $embeddings_and_chunks_query_input embeddings_and_chunks_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddingsAndChunks'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\EmbeddingsAndChunksResponse|\Carbon\Model\HTTPValidationError
     */
    public function getEmbeddingsAndChunks(

        $filters,
        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        $include_vectors = false,
        string $contentType = self::contentTypes['getEmbeddingsAndChunks'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "include_vectors", $include_vectors);
        $embeddings_and_chunks_query_input = $_body;

        list($response) = $this->getEmbeddingsAndChunksWithHttpInfo($embeddings_and_chunks_query_input, $contentType);
        return $response;
    }

    /**
     * Operation getEmbeddingsAndChunksWithHttpInfo
     *
     * Retrieve Embeddings And Content
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInput $embeddings_and_chunks_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddingsAndChunks'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\EmbeddingsAndChunksResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmbeddingsAndChunksWithHttpInfo($embeddings_and_chunks_query_input, string $contentType = self::contentTypes['getEmbeddingsAndChunks'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getEmbeddingsAndChunksRequest($embeddings_and_chunks_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->getEmbeddingsAndChunksWithHttpInfo(
                        $embeddings_and_chunks_query_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\EmbeddingsAndChunksResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\EmbeddingsAndChunksResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\EmbeddingsAndChunksResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\EmbeddingsAndChunksResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\EmbeddingsAndChunksResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmbeddingsAndChunksAsync
     *
     * Retrieve Embeddings And Content
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInput $embeddings_and_chunks_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddingsAndChunks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmbeddingsAndChunksAsync(

        $filters,
        $pagination = SENTINEL_VALUE,
        $order_by = SENTINEL_VALUE,
        $order_dir = SENTINEL_VALUE,
        $include_vectors = false,
        string $contentType = self::contentTypes['getEmbeddingsAndChunks'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "pagination", $pagination);
        $this->setRequestBodyProperty($_body, "order_by", $order_by);
        $this->setRequestBodyProperty($_body, "order_dir", $order_dir);
        $this->setRequestBodyProperty($_body, "filters", $filters);
        $this->setRequestBodyProperty($_body, "include_vectors", $include_vectors);
        $embeddings_and_chunks_query_input = $_body;

        return $this->getEmbeddingsAndChunksAsyncWithHttpInfo($embeddings_and_chunks_query_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmbeddingsAndChunksAsyncWithHttpInfo
     *
     * Retrieve Embeddings And Content
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInput $embeddings_and_chunks_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddingsAndChunks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmbeddingsAndChunksAsyncWithHttpInfo($embeddings_and_chunks_query_input, string $contentType = self::contentTypes['getEmbeddingsAndChunks'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\EmbeddingsAndChunksResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->getEmbeddingsAndChunksRequest($embeddings_and_chunks_query_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmbeddingsAndChunks'
     *
     * @param  \Carbon\Model\EmbeddingsAndChunksQueryInput $embeddings_and_chunks_query_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEmbeddingsAndChunks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEmbeddingsAndChunksRequest($embeddings_and_chunks_query_input, string $contentType = self::contentTypes['getEmbeddingsAndChunks'][0])
    {

        if ($embeddings_and_chunks_query_input !== SENTINEL_VALUE) {
            if (!($embeddings_and_chunks_query_input instanceof \Carbon\Model\EmbeddingsAndChunksQueryInput)) {
                if (!is_array($embeddings_and_chunks_query_input))
                    throw new \InvalidArgumentException('"embeddings_and_chunks_query_input" must be associative array or an instance of \Carbon\Model\EmbeddingsAndChunksQueryInput EmbeddingsApi.getEmbeddingsAndChunks.');
                else
                    $embeddings_and_chunks_query_input = new \Carbon\Model\EmbeddingsAndChunksQueryInput($embeddings_and_chunks_query_input);
            }
        }
        // verify the required parameter 'embeddings_and_chunks_query_input' is set
        if ($embeddings_and_chunks_query_input === SENTINEL_VALUE || (is_array($embeddings_and_chunks_query_input) && count($embeddings_and_chunks_query_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter embeddings_and_chunks_query_input when calling getEmbeddingsAndChunks'
            );
        }


        $resourcePath = '/text_chunks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($embeddings_and_chunks_query_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($embeddings_and_chunks_query_input));
            } else {
                $httpBody = $embeddings_and_chunks_query_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Operation uploadChunksAndEmbeddings
     *
     * Upload Chunks And Embeddings
     *
     * @param  \Carbon\Model\ChunksAndEmbeddingsUploadInput $chunks_and_embeddings_upload_input chunks_and_embeddings_upload_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadChunksAndEmbeddings'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Carbon\Model\GenericSuccessResponse|\Carbon\Model\HTTPValidationError
     */
    public function uploadChunksAndEmbeddings(

        $embedding_model,
        $chunks_and_embeddings,
        $overwrite_existing = false,
        $chunks_only = false,
        $custom_credentials = SENTINEL_VALUE,
        string $contentType = self::contentTypes['uploadChunksAndEmbeddings'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "chunks_and_embeddings", $chunks_and_embeddings);
        $this->setRequestBodyProperty($_body, "overwrite_existing", $overwrite_existing);
        $this->setRequestBodyProperty($_body, "chunks_only", $chunks_only);
        $this->setRequestBodyProperty($_body, "custom_credentials", $custom_credentials);
        $chunks_and_embeddings_upload_input = $_body;

        list($response) = $this->uploadChunksAndEmbeddingsWithHttpInfo($chunks_and_embeddings_upload_input, $contentType);
        return $response;
    }

    /**
     * Operation uploadChunksAndEmbeddingsWithHttpInfo
     *
     * Upload Chunks And Embeddings
     *
     * @param  \Carbon\Model\ChunksAndEmbeddingsUploadInput $chunks_and_embeddings_upload_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadChunksAndEmbeddings'] to see the possible values for this operation
     *
     * @throws \Carbon\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Carbon\Model\GenericSuccessResponse|\Carbon\Model\HTTPValidationError, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadChunksAndEmbeddingsWithHttpInfo($chunks_and_embeddings_upload_input, string $contentType = self::contentTypes['uploadChunksAndEmbeddings'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        ["request" => $request, "serializedBody" => $serializedBody] = $this->uploadChunksAndEmbeddingsRequest($chunks_and_embeddings_upload_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                if (
                    ($e->getCode() == 401 || $e->getCode() == 403) &&
                    !empty($this->getConfig()->getAccessToken()) &&
                    $requestOptions->shouldRetryOAuth()
                ) {
                    return $this->uploadChunksAndEmbeddingsWithHttpInfo(
                        $chunks_and_embeddings_upload_input,
                        $contentType,
                        $requestOptions->setRetryOAuth(false)
                    );
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Carbon\Model\GenericSuccessResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\GenericSuccessResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\GenericSuccessResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Carbon\Model\HTTPValidationError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Carbon\Model\HTTPValidationError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Carbon\Model\HTTPValidationError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Carbon\Model\GenericSuccessResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\GenericSuccessResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Carbon\Model\HTTPValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadChunksAndEmbeddingsAsync
     *
     * Upload Chunks And Embeddings
     *
     * @param  \Carbon\Model\ChunksAndEmbeddingsUploadInput $chunks_and_embeddings_upload_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadChunksAndEmbeddings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadChunksAndEmbeddingsAsync(

        $embedding_model,
        $chunks_and_embeddings,
        $overwrite_existing = false,
        $chunks_only = false,
        $custom_credentials = SENTINEL_VALUE,
        string $contentType = self::contentTypes['uploadChunksAndEmbeddings'][0]
    )
    {
        $_body = [];
        $this->setRequestBodyProperty($_body, "embedding_model", $embedding_model);
        $this->setRequestBodyProperty($_body, "chunks_and_embeddings", $chunks_and_embeddings);
        $this->setRequestBodyProperty($_body, "overwrite_existing", $overwrite_existing);
        $this->setRequestBodyProperty($_body, "chunks_only", $chunks_only);
        $this->setRequestBodyProperty($_body, "custom_credentials", $custom_credentials);
        $chunks_and_embeddings_upload_input = $_body;

        return $this->uploadChunksAndEmbeddingsAsyncWithHttpInfo($chunks_and_embeddings_upload_input, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadChunksAndEmbeddingsAsyncWithHttpInfo
     *
     * Upload Chunks And Embeddings
     *
     * @param  \Carbon\Model\ChunksAndEmbeddingsUploadInput $chunks_and_embeddings_upload_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadChunksAndEmbeddings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadChunksAndEmbeddingsAsyncWithHttpInfo($chunks_and_embeddings_upload_input, string $contentType = self::contentTypes['uploadChunksAndEmbeddings'][0], \Carbon\RequestOptions $requestOptions = new \Carbon\RequestOptions())
    {
        $returnType = '\Carbon\Model\GenericSuccessResponse';
        ["request" => $request, "serializedBody" => $serializedBody] = $this->uploadChunksAndEmbeddingsRequest($chunks_and_embeddings_upload_input, $contentType);

        // Customization hook
        $this->beforeSendHook($request, $requestOptions, $this->config, $serializedBody);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadChunksAndEmbeddings'
     *
     * @param  \Carbon\Model\ChunksAndEmbeddingsUploadInput $chunks_and_embeddings_upload_input (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadChunksAndEmbeddings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadChunksAndEmbeddingsRequest($chunks_and_embeddings_upload_input, string $contentType = self::contentTypes['uploadChunksAndEmbeddings'][0])
    {

        if ($chunks_and_embeddings_upload_input !== SENTINEL_VALUE) {
            if (!($chunks_and_embeddings_upload_input instanceof \Carbon\Model\ChunksAndEmbeddingsUploadInput)) {
                if (!is_array($chunks_and_embeddings_upload_input))
                    throw new \InvalidArgumentException('"chunks_and_embeddings_upload_input" must be associative array or an instance of \Carbon\Model\ChunksAndEmbeddingsUploadInput EmbeddingsApi.uploadChunksAndEmbeddings.');
                else
                    $chunks_and_embeddings_upload_input = new \Carbon\Model\ChunksAndEmbeddingsUploadInput($chunks_and_embeddings_upload_input);
            }
        }
        // verify the required parameter 'chunks_and_embeddings_upload_input' is set
        if ($chunks_and_embeddings_upload_input === SENTINEL_VALUE || (is_array($chunks_and_embeddings_upload_input) && count($chunks_and_embeddings_upload_input) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter chunks_and_embeddings_upload_input when calling uploadChunksAndEmbeddings'
            );
        }


        $resourcePath = '/upload_chunks_and_embeddings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($chunks_and_embeddings_upload_input)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($chunks_and_embeddings_upload_input));
            } else {
                $httpBody = $chunks_and_embeddings_upload_input;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('accessToken');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $headers['authorization'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('customerId');
        if ($apiKey !== null) {
            $headers['customer-id'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $method = 'POST';
        $this->beforeCreateRequestHook($method, $resourcePath, $queryParams, $headers, $httpBody);

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return [
            "request" => new Request(
                $method,
                $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
                $headers,
                $httpBody
            ),
            "serializedBody" => $httpBody
        ];
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
